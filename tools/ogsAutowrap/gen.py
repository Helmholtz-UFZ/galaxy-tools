import sys
import re
from pathlib import Path
from typing import List, Dict, Any, Tuple

from galaxyxml.tool import Tool
from galaxyxml.tool.parameters import (
    BooleanParam,
    DataParam,
    FloatParam,
    Inputs,
    IntegerParam,
    Outputs,
    SelectParam,
    TextParam,
    OutputCollection,
    DiscoverDatasets,
    Tests,
    Expand,
    Command,
    Requirements,
    Citations,
)

# --- CONFIGURATION ---
OGS_REPO_PATH = Path("/home/stehling/gitProjects/ogs")
UTILS_SUBDIR = "Applications/Utils"
OUTPUT_DIR = Path("./generated_tools")

# --- REGEX PATTERNS ---
TCLAP_PATTERN_STD = re.compile(
    r"TCLAP::(?P<arg_type>(?:Value|Switch|Multi)Arg)\s*"
    r"(?:<(?P<cpp_type>.*?)>)?\s*\w+\s*\("
    r"\s*['\"](?P<short_flag>.*?)['\"],"
    r"\s*['\"](?P<long_flag>.*?)['\"],"
    r"\s*['\"](?P<help_text>.*?)['\"](?P<remaining_args>.*?)\);",
    re.DOTALL
)
TCLAP_PATTERN_UNLABELED = re.compile(
    r"TCLAP::(?P<arg_type>Unlabeled(?:Value|Multi)Arg)\s*"
    r"(?:<(?P<cpp_type>.*?)>)?\s*\w+\s*\("
    r"\s*['\"](?P<name_as_flag>.*?)['\"],"
    r"\s*['\"](?P<help_text>.*?)['\"](?P<remaining_args>.*?)\);",
    re.DOTALL
)
# Regex to find the broken <node> block generated by the library
BROKEN_NODE_PATTERN = re.compile(r"<node.*?>.*?</node>", re.DOTALL)


def eprint(*args, **kwargs):
    """Schreibt nach stderr."""
    print(*args, file=sys.stderr, **kwargs)

def sanitize_name(name: str) -> str:
    """Bereinigt einen String, um ein gültiger Galaxy-Parametername zu sein."""
    return re.sub(r'[^a-zA-Z0-9_]+', '_', name)

def discover_tools() -> List[Dict[str, Any]]:
    # Diese Funktion bleibt unverändert
    base_path = OGS_REPO_PATH / UTILS_SUBDIR
    if not base_path.is_dir():
        eprint(f"ERROR: The subdirectory '{base_path}' does not exist.")
        return []
    source_files = list(base_path.glob("**/*.cpp"))
    tools_dict: Dict[str, Dict[str, Any]] = {}
    eprint(f"Searching {len(source_files)} potential .cpp files...")
    for file_path in source_files:
        content = file_path.read_text(encoding='utf-8', errors='ignore')
        std_matches = list(TCLAP_PATTERN_STD.finditer(content))
        unlabeled_matches = list(TCLAP_PATTERN_UNLABELED.finditer(content))
        if not (std_matches or unlabeled_matches):
            continue
        tool_name = file_path.parent.name if file_path.name == 'main.cpp' else file_path.stem
        if tool_name.lower() in ["main", "utils"]:
            continue
        if tool_name not in tools_dict:
            tools_dict[tool_name] = {"name": tool_name, "parameters": []}
        for match in std_matches:
            param_data = match.groupdict()
            param_data['is_unlabeled'] = False
            tools_dict[tool_name]["parameters"].append(param_data)
        for match in unlabeled_matches:
            param_data = match.groupdict()
            param_data['long_flag'] = param_data.pop('name_as_flag')
            param_data['is_unlabeled'] = True
            tools_dict[tool_name]["parameters"].append(param_data)
    all_tools_data = list(tools_dict.values())
    eprint(f"-> Found and processed {len(all_tools_data)} tools with TCLAP definitions.")
    return sorted(all_tools_data, key=lambda x: x['name'])


def process_parameters(tclap_params: List[Dict[str, Any]]) -> Tuple[List[object], Dict[str, str]]:
    # Diese Funktion bleibt unverändert
    galaxy_inputs = []
    output_command_map = {}
    output_idx = 1
    for param_info in tclap_params:
        for key in ['long_flag', 'help_text', 'remaining_args']:
            if key in param_info and param_info[key]:
                param_info[key] = ' '.join(param_info[key].replace('"', '').replace('\\n', ' ').split())
        long_flag = param_info['long_flag']
        if not long_flag:
            continue
        help_text = param_info['help_text']
        var_name = sanitize_name(long_flag)
        is_output = 'output' in long_flag.lower()
        if is_output:
            format_match = re.search(r"\*\.([a-zA-Z0-9_]+)", help_text)
            file_format = format_match.group(1) if format_match else 'dat'
            static_filename = f"output_{output_idx}.{file_format}"
            output_command_map[long_flag] = static_filename
            output_idx += 1
            continue
        is_required = 'true' in param_info.get('remaining_args', '') or 'ValueArg' in param_info['arg_type']
        attrs = { "name": var_name, "label": help_text.split('.')[0] or long_flag, "help": help_text, "optional": not is_required }
        standard_match = re.search(r"\(standard:\s*([^)]+)\)", help_text)
        if standard_match:
            attrs['value'] = standard_match.group(1).strip()
            attrs['optional'] = False
        allowed_match = re.search(r"\(allowed values:\s*([^)]+)\)", help_text)
        if allowed_match:
            options = [opt.strip() for opt in allowed_match.group(1).split(',')]
            galaxy_inputs.append(SelectParam(options=dict([(o,o) for o in options]), **attrs))
            continue
        long_flag_lower, help_text_lower = long_flag.lower(), help_text.lower()
        is_likely_input_file = ('input' in long_flag_lower or 'mesh' in long_flag_lower) and \
                               ('file' in help_text_lower or 'mesh' in help_text_lower or re.search(r"\*\.([a-zA-Z0-9_]+)", help_text))
        if is_likely_input_file:
            format_match = re.search(r"\*\.([a-zA-Z0-9_]+)", help_text)
            attrs['format'] = format_match.group(1) if format_match else 'auto'
            attrs['multiple'] = "list" in help_text_lower or "MultiArg" in param_info['arg_type']
            galaxy_inputs.append(DataParam(**attrs))
            continue
        if param_info['arg_type'] == "SwitchArg":
            attrs.pop('optional', None)
            attrs.update(truevalue=f"--{long_flag}", falsevalue="", checked=False)
            galaxy_inputs.append(BooleanParam(**attrs))
            continue
        cpp_type = param_info.get('cpp_type', '')
        param_class = IntegerParam if "int" in cpp_type else FloatParam if "float" in cpp_type or "double" in cpp_type else TextParam
        min_max_search = re.findall(r"\((min|max)\s*=\s*([^)]+)\)", help_text)
        if min_max_search:
            for key, val in min_max_search:
                attrs[key] = val.strip()
        galaxy_inputs.append(param_class(**attrs))
    return galaxy_inputs, output_command_map


def main():
    """Hauptfunktion: Findet Tools und generiert für jedes eine XML-Datei."""
    if not OGS_REPO_PATH.is_dir():
        eprint(f"ERROR: The OGS repository directory '{OGS_REPO_PATH}' was not found.")
        return

    OUTPUT_DIR.mkdir(exist_ok=True)
    parsed_tools = discover_tools()
    if not parsed_tools:
        eprint("No tools with TCLAP definitions found. Aborting.")
        return

    generated_count = 0
    for tool_data in parsed_tools:
        tool_name = tool_data['name']
        eprint(f"Generating wrapper for: {tool_name}...")
        try:
            galaxy_inputs, output_command_map = process_parameters(tool_data['parameters'])
            
            command_lines = [tool_name]
            for param in galaxy_inputs:
                param_var = f'${param.name}'
                original_long_flag = next((p['long_flag'] for p in tool_data['parameters'] if sanitize_name(p['long_flag']) == param.name), "")
                is_unlabeled = any(p.get('is_unlabeled', False) for p in tool_data['parameters'] if sanitize_name(p['long_flag']) == param.name)

                if isinstance(param, BooleanParam):
                    command_lines.append(f"    {param_var}")
                elif is_unlabeled:
                    command_lines.append(f"    '${param_var}'")
                elif getattr(param, 'multiple', False):
                    command_lines.append(f"    #for $f in {param_var}:")
                    command_lines.append(f"        --{original_long_flag} '$f'")
                    command_lines.append(f"    #end for")
                else:
                    is_truly_optional = str(getattr(param, 'optional', True)).lower() == 'true'
                    if is_truly_optional:
                        command_lines.append(f"    #if str($param.name) and $param.name != 'None':")
                        command_lines.append(f"        --{original_long_flag} '${param_var}'")
                        command_lines.append(f"    #end if")
                    else:
                        command_lines.append(f"    --{original_long_flag} '${param_var}'")

            for flag, filename in output_command_map.items():
                command_lines.append(f"    --{flag} '{filename}'")
            
            command_str = "\n".join(command_lines)

            # Wir lassen die Bibliothek den Rest des Tools erstellen.
            # command_override wird ignoriert, also lassen wir es weg.
            tool = Tool(
                name=f"OGS: {tool_name}",
                id=f"ogs_{tool_name.lower()}",
                executable=tool_name,
                version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@",
                description=f"Galaxy wrapper for the OGS utility '{tool_name}'.",
                macros=["macros.xml"],
                profile="22.01",
                version_command=f"{tool_name} --version",
            )
            
            requirements_tag = tool.requirements = Requirements()
            requirements_tag.append(Expand(macro="requirements"))
            requirements_tag.append(Expand(macro="interpreter"))

            tool.inputs = Inputs(children=galaxy_inputs)

            if output_command_map:
                outputs_tag = tool.outputs = Outputs()
                collection = OutputCollection(name="tool_outputs", type="list", label=f"Outputs from {tool_name}")
                collection.append(DiscoverDatasets(pattern=r"output_.+\..+", format="auto", visible=True))
                outputs_tag.append(collection)

            tool.tests = Tests(children=[Expand(macro="ogsutilssuite_tests")])
            tool.help = f"This tool runs the **{tool_name}** utility from the OpenGeoSys suite."
            tool.citations = Citations(children=[Expand(macro="citations")])
            
            # --- MANUELLE KORREKTUR ---
            # 1. Erzeuge den fehlerhaften XML-String im Speicher
            broken_xml_string = tool.export()
            
            # 2. Erstelle den korrekten Command-Block
            correct_command_block = f"""<command detect_errors="aggressive"><![CDATA[
{command_str}
]]></command>"""
            
            # 3. Ersetze den fehlerhaften <node>-Block durch den korrekten <command>-Block
            # Wir gehen davon aus, dass der <node>-Block direkt nach <version_command> kommt
            # und ersetzen ihn. Wenn kein <node>-Block da ist, fügen wir den command-Block
            # nach der version_command ein.
            
            # Zuerst den <node>-Block entfernen, falls vorhanden
            xml_without_node = BROKEN_NODE_PATTERN.sub("", broken_xml_string)
            
            # Dann den korrekten <command>-Block an der richtigen Stelle einfügen
            # (nach dem version_command-Tag)
            version_command_tag_end = f"</version_command>"
            final_xml_string = xml_without_node.replace(
                version_command_tag_end,
                f"{version_command_tag_end}\n  {correct_command_block}"
            )

            output_file_path = OUTPUT_DIR / f"{tool_name}.xml"
            with open(output_file_path, 'w', encoding='utf-8') as f:
                f.write(final_xml_string)
                
            eprint(f"-> Successfully saved: {output_file_path}")
            generated_count += 1
        except Exception as e:
            eprint(f"!! ERROR while processing '{tool_name}': {e}")
            import traceback
            traceback.print_exc(file=sys.stderr)

    eprint(f"\nFinished. {generated_count} of {len(parsed_tools)} tool wrappers were created in the '{OUTPUT_DIR}' directory.")

if __name__ == "__main__":
    main()