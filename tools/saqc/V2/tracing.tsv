ModuleName	ParameterName	TypeAnnotation	FinalXML	TracePath
saqc.funcs.breaks	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.breaks	gap_window	OffsetStr	"<param type=""text"" argument=""gap_window"" label=""Minimum gap size required before and after a data group to consider it isolated"" help=""See condition (2) and (3)"" />"	Param: 'gap_window' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.breaks	group_window	OffsetStr	"<param type=""text"" argument=""group_window"" label=""Maximum size of a data chunk to consider it a candidate for an isolated group"" help=""Data chunks that are bigger than the `group_window` are ignored. This does not include the possible gaps surrounding it. See condition (1)"" />"	Param: 'group_window' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.breaks	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.breaks	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.breaks	thresh	Float >= 0	"<param type=""float"" argument=""thresh"" label=""Threshold value by which the mean of data has to jump, to trigger flagging"" help=""Threshold value by which the mean of data has to jump, to trigger flagging"" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.breaks	window	OffsetStr	"<param type=""text"" argument=""window"" label=""Size of the two moving windows"" help=""This determines the number of observations used for calculating the mean in every window. The window size should be big enough to yield enough samples for a reliable mean calculation, but it should also not be arbitrarily big, since it also limits the density of jumps that can be detected. More precisely: Jumps that are not distanced to each other by more than three fourth (3/4) of the selected `window` size, will not be detected reliably"" />"	Param: 'window' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.breaks	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""The minimum number of observations in `window` required to calculate a valid mean value"" optional=""true"" value=""0"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.breaks	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.breaks	dfilter	float	"<param type=""float"" argument=""dfilter"" label=""dfilter"" help="":py:class:`Any`, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme"" optional=""true"" value=""-inf"" />"	Param: 'dfilter' -> Annotation: 'float' -> is_simple_type
saqc.funcs.breaks	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.breaks	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.breaks	dfilter	float	"<param type=""float"" argument=""dfilter"" label=""dfilter"" help="":py:class:`Any`, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme"" optional=""true"" value=""-inf"" />"	Param: 'dfilter' -> Annotation: 'float' -> is_simple_type
saqc.funcs.changepoints	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.changepoints	stat_func	Callable[[np.ndarray, np.ndarray], float]	"<param type=""text"" argument=""stat_func"" label=""A function that assigns a value to every twin window"" help=""Left window content will be passed to first variable, right window content will be passed to the second"" />"	Param: 'stat_func' -> Annotation: 'Callable[[np.ndarray, np.ndarray], float]' -> is_simple_type
saqc.funcs.changepoints	thresh_func	Callable[[np.ndarray, np.ndarray], float]	"<param type=""text"" argument=""thresh_func"" label=""thresh_func"" help=""A function that determines the value level, exceeding wich qualifies a timestamps func value as denoting a changepoint"" />"	Param: 'thresh_func' -> Annotation: 'Callable[[np.ndarray, np.ndarray], float]' -> is_simple_type
saqc.funcs.changepoints	window	OffsetStr | tuple[OffsetStr, OffsetStr]	"<conditional name=""window_cond"" label=""Size of the rolling windows the calculation is performed in"" />"	Param: 'window' -> Annotation: 'OffsetStr | tuple[OffsetStr, OffsetStr]' -> is_union_type -> conditional
saqc.funcs.changepoints	min_periods	(Int >= 0) | tuple[Int >= 0, Int >= 0]	"<conditional name=""min_periods_cond"" label=""min_periods"" />"	Param: 'min_periods' -> Annotation: '(Int >= 0) | tuple[Int >= 0, Int >= 0]' -> is_union_type -> conditional
saqc.funcs.changepoints	reduce_window	OffsetStr | None	"<param type=""text"" argument=""reduce_window"" label=""reduce_window"" help=""The sliding window search method is not an exact CP search method and usually there won't be detected a single changepoint, but a  region  of change around a changepoint. If `reduce_window` is given, for every window of size `reduce_window`, there will be selected the value with index `reduce_func(x, y)` and the others will be dropped. If `reduce_window` is None, the reduction window size equals the twin window size, the changepoints have been detected with"" optional=""true"" />"	Param: 'reduce_window' -> Annotation: 'OffsetStr | None' -> is_simple_type
saqc.funcs.changepoints	reduce_func	Callable[[np.ndarray, np.ndarray], float]	"<param type=""text"" argument=""reduce_func"" label=""reduce_func"" help=""default argmax A function that must return an index value upon input of two arrays x and y. First input parameter will hold the result from the stat_func evaluation for every reduction window. Second input parameter holds the result from the thresh_func evaluation. The default reduction function just selects the value that maximizes the stat_func"" optional=""true"" />"	Param: 'reduce_func' -> Annotation: 'Callable[[np.ndarray, np.ndarray], float]' -> is_simple_type
saqc.funcs.changepoints	model_by_resids	bool	"<param type=""boolean"" argument=""model_by_resids"" label=""If True, the results of `stat_funcs` are written, otherwise the regime labels"" help=""If True, the results of `stat_funcs` are written, otherwise the regime labels"" checked=""false"" truevalue=""model_by_resids"" falsevalue="""" />"	Param: 'model_by_resids' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.changepoints	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.changepoints	stat_func	Callable[[np.ndarray, np.ndarray], float]	"<param type=""text"" argument=""stat_func"" label=""A function that assigns a value to every twin window"" help=""The backward-facing window content will be passed as the first array, the forward-facing window content as the second"" />"	Param: 'stat_func' -> Annotation: 'Callable[[np.ndarray, np.ndarray], float]' -> is_simple_type
saqc.funcs.changepoints	thresh_func	Callable[[np.ndarray, np.ndarray], float]	"<param type=""text"" argument=""thresh_func"" label=""thresh_func"" help=""A function that determines the value level, exceeding wich qualifies a timestamps func value as denoting a change-point"" />"	Param: 'thresh_func' -> Annotation: 'Callable[[np.ndarray, np.ndarray], float]' -> is_simple_type
saqc.funcs.changepoints	window	OffsetStr | tuple[OffsetStr, OffsetStr]	"<conditional name=""window_cond"" label=""Size of the moving windows"" />"	Param: 'window' -> Annotation: 'OffsetStr | tuple[OffsetStr, OffsetStr]' -> is_union_type -> conditional
saqc.funcs.changepoints	min_periods	(Int >= 0) | tuple[Int >= 0, Int >= 0]	"<conditional name=""min_periods_cond"" label=""min_periods"" />"	Param: 'min_periods' -> Annotation: '(Int >= 0) | tuple[Int >= 0, Int >= 0]' -> is_union_type -> conditional
saqc.funcs.changepoints	reduce_window	OffsetStr | None	"<param type=""text"" argument=""reduce_window"" label=""reduce_window"" help=""The sliding window search method is not an exact CP search method and usually there wont be detected a single changepoint, but a  region  of change around a changepoint.  If `reduce_window` is given, for every window of size `reduce_window`, there will be selected the value with index `reduce_func(x, y)` and the others will be dropped.  If `reduce_window` is None, the reduction window size equals the twin window size, the changepoints have been detected with"" optional=""true"" />"	Param: 'reduce_window' -> Annotation: 'OffsetStr | None' -> is_simple_type
saqc.funcs.changepoints	reduce_func	Callable[[np.ndarray, np.ndarray], int]	"<param type=""text"" argument=""reduce_func"" label=""reduce_func"" help=""default argmax A function that must return an index value upon input of two arrays x and y. First input parameter will hold the result from the stat_func evaluation for every reduction window. Second input parameter holds the result from the `thresh_func` evaluation. The default reduction function just selects the value that maximizes the `stat_func`"" optional=""true"" />"	Param: 'reduce_func' -> Annotation: 'Callable[[np.ndarray, np.ndarray], int]' -> is_simple_type
saqc.funcs.changepoints	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.constants	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.constants	window	OffsetStr	"<param type=""text"" argument=""window"" label=""Size of the moving window"" help=""This is the number of observations used for calculating the statistic. Each window will be a fixed size. If its an offset then this will be the time period of each window. Each window will be sized, based on the number of observations included in the time-period"" />"	Param: 'window' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.constants	thresh	Float >= 0	"<param type=""float"" argument=""thresh"" label=""Maximum total variance allowed per window"" help=""Maximum total variance allowed per window"" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.constants	maxna	(Int >= 0) | None	"<param type=""integer"" argument=""maxna"" label=""Maximum number of NaNs allowed in window"" help=""If more NaNs are present, the window is not flagged"" optional=""true"" min=""0"" />"	Param: 'maxna' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.constants	maxna_group	(Int >= 0) | None	"<param type=""integer"" argument=""maxna_group"" label=""Same as `maxna` but for consecutive NaNs"" help=""Same as `maxna` but for consecutive NaNs"" optional=""true"" min=""0"" />"	Param: 'maxna_group' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.constants	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.constants	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.constants	thresh	Float >= 0	"<param type=""float"" argument=""thresh"" label=""Maximum total change allowed per window"" help=""Maximum total change allowed per window"" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.constants	window	OffsetStr | (Int >= 1)	"<conditional name=""window_cond"" label=""Size of the moving window"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int >= 1)' -> is_union_type -> conditional
saqc.funcs.constants	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""Minimum number of observations in window required to generate a flag"" help=""This can be used to exclude underpopulated *offset* defined windows from flagging. (Integer defined windows will always contain exactly *window* samples). Must be an integer greater or equal `2`, because a single value would always be considered constant. Defaults to `2`"" optional=""true"" value=""2"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.constants	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.curvefit	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.curvefit	cutoff	(Float >= 0) | FreqStr	"<conditional name=""cutoff_cond"" label=""cutoff"" />"	Param: 'cutoff' -> Annotation: '(Float >= 0) | FreqStr' -> is_union_type -> conditional
saqc.funcs.curvefit	nyq	Float >= 0	"<param type=""float"" argument=""nyq"" label=""The niquist-frequency"" help=""expressed in multiples if the sampling rate"" optional=""true"" value=""0.5"" min=""0"" />"	Param: 'nyq' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.curvefit	filter_order	Int >= 1	"<param type=""integer"" argument=""filter_order"" label=""filter_order"" help="""" optional=""true"" value=""2"" min=""1"" />"	Param: 'filter_order' -> Annotation: 'Int >= 1' -> is_simple_type
saqc.funcs.curvefit	fill_method	FILL_METHODS	"<param type=""select"" argument=""fill_method"" label=""fill_method"" help=""Fill method to be applied on the data before filtering (butterfilter cant handle ''np.nan''). See documentation of pandas.Series.interpolate method for details on the methods associated with the different keywords"" optional=""true"" value=""linear"" />"	Param: 'fill_method' -> Annotation: 'FILL_METHODS' -> is_simple_type
saqc.funcs.curvefit	field	str | list[str]	"<conditional name=""field_cond"" label=""Variable to process"" />"	Param: 'field' -> Annotation: 'str | list[str]' -> is_union_type -> conditional
saqc.funcs.curvefit	ratio	int	"<param type=""integer"" argument=""ratio"" label=""The number of samples generated for any values reconstruction"" help=""Must be a divisor of `context`. Effectively controlls the stride-width of the reconstruction window through the data"" optional=""true"" value=""4"" />"	Param: 'ratio' -> Annotation: 'int' -> is_simple_type
saqc.funcs.curvefit	context	int	"<param type=""integer"" argument=""context"" label=""context"" help=""size of the context window with regard to wich any value is reconstructed"" optional=""true"" value=""512"" />"	Param: 'context' -> Annotation: 'int' -> is_simple_type
saqc.funcs.curvefit	agg	Literal['center', 'mean', 'median', 'std']	"<param type=""select"" argument=""agg"" label=""How to aggregate the different reconstructions for the same value"" help=""* 'center': use the value that was constructed in a window centering around the origin value * 'mean': assign the mean over all reconstructed values * 'median': assign the median over all reconstructed values * 'std': assign the standard deviation over all reconstructed values"" optional=""true"" value=""mean"" />"	Param: 'agg' -> Annotation: 'Literal['center', 'mean', 'median', 'std']' -> is_simple_type
saqc.funcs.curvefit	model_spec	dict | None	"<repeat name=""model_spec"" help=""Dictionary with the fields: * `pretrained_model_name_or_path` * `revision`  Defaults to global Parameter `DEFAULT_MOMENT=dict(pretrained_model_name_or_path= AutonLab/MOMENT-1-large , revision= main `"" title=""model_spec"" />"	Param: 'model_spec' -> Annotation: 'dict | None' -> is_simple_type
saqc.funcs.curvefit	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.curvefit	window	OffsetStr | (Int >= 0)	"<conditional name=""window_cond"" label=""Size of the window you want to use for fitting"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int >= 0)' -> is_union_type -> conditional
saqc.funcs.curvefit	order	Int >= 1	"<param type=""integer"" argument=""order"" label=""Degree of the polynomial used for fitting"" help=""Degree of the polynomial used for fitting"" min=""1"" />"	Param: 'order' -> Annotation: 'Int >= 1' -> is_simple_type
saqc.funcs.curvefit	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of observations in a window required to perform the fit, otherwise NaNs will be assigned. If ``None``, `min_periods` defaults to 1 for integer windows and to the size of the window for offset based windows. Passing 0, disables the feature and will result in over-fitting for too sparse windows"" optional=""true"" value=""0"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.drift	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	cluster_field	str	"<param type=""text"" argument=""cluster_field"" label=""Column in data, holding the cluster labels for the samples in field"" help=""(has to be indexed equal to field)"" />"	Param: 'cluster_field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	spread	Float >= 0	"<param type=""float"" argument=""spread"" label=""A threshold denoting the value level, up to wich clusters a agglomerated"" help=""A threshold denoting the value level, up to wich clusters a agglomerated"" min=""0"" />"	Param: 'spread' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.drift	method	LINKAGE_STRING	"<param type=""select"" argument=""method"" label=""The linkage method for hierarchical (agglomerative) clustering of the variables"" help=""The linkage method for hierarchical (agglomerative) clustering of the variables"" optional=""true"" value=""single"" />"	Param: 'method' -> Annotation: 'LINKAGE_STRING' -> is_simple_type
saqc.funcs.drift	metric	Callable[[np.ndarray, np.ndarray], float]	"<param type=""text"" argument=""metric"" label=""A metric function for calculating the dissimilarity between 2 regimes"" help=""Defaults to the absolute difference in mean"" optional=""true"" />"	Param: 'metric' -> Annotation: 'Callable[[np.ndarray, np.ndarray], float]' -> is_simple_type
saqc.funcs.drift	frac	Float[0, 1]	"<param type=""float"" argument=""frac"" label=""frac"" help=""The minimum percentage of samples, the  normal  group has to comprise to actually be the normal group. Must be in the closed interval `[0,1]`, otherwise a ValueError is raised"" optional=""true"" value=""0.5"" min=""0"" max=""1"" />"	Param: 'frac' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.drift	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	maintenance_field	str	"<param type=""text"" argument=""maintenance_field"" label=""Column holding the support-points information"" help=""The data is expected to have the following form: The index of the series represents the beginning of a maintenance event, wheras the values represent its endings"" />"	Param: 'maintenance_field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	model	CurveFitter | Literal['linear', 'exponential']	"<conditional name=""model_cond"" label=""A model function describing the drift behavior, that is to be corrected"" />"	Param: 'model' -> Annotation: 'CurveFitter | Literal['linear', 'exponential']' -> is_union_type -> conditional
saqc.funcs.drift	cal_range	Int >= 0	"<param type=""integer"" argument=""cal_range"" label=""cal_range"" help=""Number of values to calculate the mean of, for obtaining the value level directly after and directly before a maintenance event. Needed for shift calibration"" optional=""true"" value=""5"" min=""0"" />"	Param: 'cal_range' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.drift	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	max_jump	Float >= 0	"<param type=""float"" argument=""max_jump"" label=""max_jump"" help=""when searching for changepoints in mean - this is the threshold a mean difference in the sliding window search must exceed to trigger changepoint detection"" min=""0"" />"	Param: 'max_jump' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.drift	spread	Float >= 0	"<param type=""float"" argument=""spread"" label=""spread"" help=""threshold denoting the maximum, regimes are allowed to abolutely differ in their means to form the  normal group  of values"" min=""0"" />"	Param: 'spread' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.drift	window	OffsetStr	"<param type=""text"" argument=""window"" label=""Size of the adjacent windows that are used to search for the mean changepoints"" help=""Size of the adjacent windows that are used to search for the mean changepoints"" />"	Param: 'window' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.drift	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of periods a search window has to contain, for the result of the changepoint detection to be considered valid"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.drift	tolerance	OffsetStr | None	"<param type=""text"" argument=""tolerance"" label=""tolerance"" help=""If an offset string is passed, a data chunk of length `offset` right from the start and right before the end of any regime is ignored when calculating a regimes mean for data correcture. This is to account for the unrelyability of data near the changepoints of regimes"" optional=""true"" />"	Param: 'tolerance' -> Annotation: 'OffsetStr | None' -> is_simple_type
saqc.funcs.drift	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	cluster_field	str	"<param type=""text"" argument=""cluster_field"" label=""cluster_field"" help=""A string denoting the field in data, holding the cluster label for the data you want to correct"" />"	Param: 'cluster_field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	model	CurveFitter	"<param type=""text"" argument=""model"" label=""The model function to be fitted to the regimes"" help=""It must be a function of the form :math:`f(x, *p)`, where :math:`x` is the ``numpy.array`` holding the independent variables and :math:`p` are the model parameters that are to be obtained by fitting. Depending on the `x_date` parameter, independent variable x will either be the timestamps of every regime transformed to seconds from epoch, or it will be just seconds, counting the regimes length"" />"	Param: 'model' -> Annotation: 'CurveFitter' -> is_simple_type
saqc.funcs.drift	tolerance	OffsetStr | None	"<param type=""text"" argument=""tolerance"" label=""tolerance"" help=""If an offset string is passed, a data chunk of length `offset` right at the start and right at the end is ignored when fitting the model. This is to account for the unreliability of data near the changepoints of regimes. Defaults to None"" optional=""true"" />"	Param: 'tolerance' -> Annotation: 'OffsetStr | None' -> is_simple_type
saqc.funcs.drift	epoch	bool	"<param type=""boolean"" argument=""epoch"" label=""epoch"" help=""If True, use  seconds from epoch  as x input to the model func, instead of  seconds from regime start "" checked=""false"" truevalue=""epoch"" falsevalue="""" />"	Param: 'epoch' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.drift	field	Sequence[str]	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'Sequence[str]' -> is_simple_type
saqc.funcs.drift	window	OffsetStr	"<param type=""text"" argument=""window"" label=""Frequency, that split the data in chunks"" help=""Frequency, that split the data in chunks"" />"	Param: 'window' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.drift	spread	Float >= 0	"<param type=""float"" argument=""spread"" label=""Maximum spread allowed in the group of *normal* data"" help=""See Notes section for more details"" min=""0"" />"	Param: 'spread' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.drift	frac	Float[0, 1]	"<param type=""float"" argument=""frac"" label=""Fraction defining the normal group"" help=""Use a value from the interval [0,1]. The higher the value, the more stable the algorithm will be. For values below 0.5 the results are undefined"" optional=""true"" value=""0.5"" min=""0"" max=""1"" />"	Param: 'frac' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.drift	metric	Callable[[np.ndarray | pd.Series, np.ndarray | pd.Series], np.ndarray]	"<param type=""text"" argument=""metric"" label=""metric"" help=""default cityblock Distance function that takes two arrays as input and returns a scalar float. This value is interpreted as the distance of the two input arrays. Defaults to the `averaged manhattan metric` (see Notes)"" optional=""true"" />"	Param: 'metric' -> Annotation: 'Callable[[np.ndarray | pd.Series, np.ndarray | pd.Series], np.ndarray]' -> is_simple_type
saqc.funcs.drift	method	LINKAGE_STRING	"<param type=""select"" argument=""method"" label=""Linkage method used for hierarchical (agglomerative) clustering of the data"" help=""`method` is directly passed to ``scipy.hierarchy.linkage``. See its documentation [1] for more details. For a general introduction on hierarchical clustering see [2]"" optional=""true"" value=""single"" />"	Param: 'method' -> Annotation: 'LINKAGE_STRING' -> is_simple_type
saqc.funcs.drift	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.drift	field	Sequence[str]	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'Sequence[str]' -> is_simple_type
saqc.funcs.drift	reference	str	"<param type=""text"" argument=""reference"" label=""Reference variable, the deviation is calculated from"" help=""Reference variable, the deviation is calculated from"" />"	Param: 'reference' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	freq	FreqStr	"<param type=""text"" argument=""freq"" label=""Frequency, that split the data in chunks"" help=""Frequency, that split the data in chunks"" />"	Param: 'freq' -> Annotation: 'FreqStr' -> is_simple_type
saqc.funcs.drift	thresh	Float >= 0	"<param type=""float"" argument=""thresh"" label=""Maximum deviation from reference"" help=""Maximum deviation from reference"" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.drift	metric	Callable[[np.ndarray | pd.Series, np.ndarray | pd.Series], np.ndarray]	"<param type=""text"" argument=""metric"" label=""metric"" help=""default cityblock Distance function. Takes two arrays as input and returns a scalar float. This value is interpreted as the mutual distance of the two input arrays. Defaults to the `averaged manhattan metric` (see Notes)"" optional=""true"" />"	Param: 'metric' -> Annotation: 'Callable[[np.ndarray | pd.Series, np.ndarray | pd.Series], np.ndarray]' -> is_simple_type
saqc.funcs.drift	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.drift	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	cluster_field	str	"<param type=""text"" argument=""cluster_field"" label=""Column in data, holding the cluster labels for the samples in field"" help=""(has to be indexed equal to field)"" />"	Param: 'cluster_field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.drift	spread	Float >= 0	"<param type=""float"" argument=""spread"" label=""A threshold denoting the value level, up to wich clusters a agglomerated"" help=""A threshold denoting the value level, up to wich clusters a agglomerated"" min=""0"" />"	Param: 'spread' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.drift	method	LINKAGE_STRING	"<param type=""select"" argument=""method"" label=""The linkage method for hierarchical (agglomerative) clustering of the variables"" help=""The linkage method for hierarchical (agglomerative) clustering of the variables"" optional=""true"" value=""single"" />"	Param: 'method' -> Annotation: 'LINKAGE_STRING' -> is_simple_type
saqc.funcs.drift	metric	Callable[[np.ndarray | pd.Series, np.ndarray | pd.Series], float]	"<param type=""text"" argument=""metric"" label=""A metric function for calculating the dissimilarity between 2 regimes"" help=""Defaults to the absolute difference in mean"" optional=""true"" />"	Param: 'metric' -> Annotation: 'Callable[[np.ndarray | pd.Series, np.ndarray | pd.Series], float]' -> is_simple_type
saqc.funcs.drift	frac	Float[0, 1]	"<param type=""float"" argument=""frac"" label=""frac"" help=""The minimum percentage of samples, the  normal  group has to comprise to actually be the normal group. Must be in the closed interval `[0,1]`, otherwise a ValueError is raised"" optional=""true"" value=""0.5"" min=""0"" max=""1"" />"	Param: 'frac' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.drift	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.flagtools	target	SaQCFields | None	"<param type=""text"" argument=""target"" label=""target"" help="":py:class:`SaQCFields` | :py:class:`newSaQCFields` , optional Variable name to which the results are written. `target` will be created if it does not exist. Defaults to `field`"" optional=""true"" multiple=""true"" />"	Param: 'target' -> Annotation: 'SaQCFields | None' -> is_simple_type
saqc.funcs.flagtools	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.flagtools	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.flagtools	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.flagtools	mdata	str | pd.Series | ArrayLike | list | pd.DataFrame	"<conditional name=""mdata_cond"" label=""Determines which values or intervals will be flagged"" />"	Param: 'mdata' -> Annotation: 'str | pd.Series | ArrayLike | list | pd.DataFrame' -> is_union_type -> conditional
saqc.funcs.flagtools	method	Literal['left-open', 'right-open', 'closed', 'plain', 'ontime']	"<param type=""select"" argument=""method"" label=""method"" help=""Defines how `mdata` is projected to data:  * `` plain ``: `mdata` must have the same length as `field`, flags are set, where the values in `mdata` equal `mflag`. * `` ontime ``: Expects datetime indexed `mdata` (types ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``). Flags are set, where the values in `mdata` equal `mflag` and the indices of `field` and `mdata` match. * `` right-open ``: Expects datetime indexed `mdata`, which will be interpreted as a number of time intervals ``t_1, t_2``. Flags are set to all timestamps ``t`` of `field` with ``t_1  = t   t_2``. * `` left-open ``: like `` right-open ``, but the interval covers all ``t`` with ``t_1   t  = t_2``. * `` closed ``: like `` right-open ``, but the interval now covers all ``t`` with ``t_1  = t  = t_2``"" optional=""true"" value=""left-open"" />"	Param: 'method' -> Annotation: 'Literal['left-open', 'right-open', 'closed', 'plain', 'ontime']' -> is_simple_type
saqc.funcs.flagtools	mformat	Literal['start-end', 'mflag']	"<param type=""select"" argument=""mformat"" label=""mformat"" help=""Controls the interval definition in `mdata` (see examples):  * `` start-end ``: expects datetime indexed `mdata` (types ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``) with values of type datetime. Each index-value pair is interpreted as an interval to flag, the index defines the left bound, the respective value the right bound. * `` mflag ``:  - `mdata` of type ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``: Two successive index values ``i_1, i_2`` will be interpreted as an interval ``t_1, t_2`` to flag, if the value of ``t_1`` equals `mflag` - `mdata` of type ``list``, ``np.ndarray``: Flags all `field` where `mdata` euqals `mflag`"" optional=""true"" value=""start-end"" />"	Param: 'mformat' -> Annotation: 'Literal['start-end', 'mflag']' -> is_simple_type
saqc.funcs.flagtools	mflag	Any	"<param type=""text"" argument=""mflag"" label=""mflag"" help=""Value in `mdata` indicating that a flag should be set at the respective position, timestamp or interval. Ignored if `mformat` is set to `` start-end ``"" optional=""true"" value=""1"" />"	Param: 'mflag' -> Annotation: 'Any' -> is_simple_type
saqc.funcs.flagtools	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.flagtools	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.flagtools	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="""" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.flagtools	target	SaQCFields | None	"<param type=""text"" argument=""target"" label=""target"" help="":py:class:`SaQCFields` | :py:class:`newSaQCFields` , optional Variable name to which the results are written. `target` will be created if it does not exist. Defaults to `field`"" optional=""true"" multiple=""true"" />"	Param: 'target' -> Annotation: 'SaQCFields | None' -> is_simple_type
saqc.funcs.flagtools	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.flagtools	window	OffsetStr | (Int > 0)	"<conditional name=""window_cond"" label=""Size of the repetition window"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int > 0)' -> is_union_type -> conditional
saqc.funcs.flagtools	method	Literal['ffill', 'bfill']	"<param type=""select"" argument=""method"" label=""Direction of repetetion"" help=""With  ffill  the subsequent values receive the flag to repeat, with  bfill  the previous values"" optional=""true"" value=""ffill"" />"	Param: 'method' -> Annotation: 'Literal['ffill', 'bfill']' -> is_simple_type
saqc.funcs.flagtools	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	dfilter	float	"<param type=""float"" argument=""dfilter"" label=""dfilter"" help="":py:class:`Any`, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme"" optional=""true"" value=""-inf"" />"	Param: 'dfilter' -> Annotation: 'float' -> is_simple_type
saqc.funcs.flagtools	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.flagtools	target	SaQCFields | NewSaQCFields | None	"<conditional name=""target_cond"" label=""target"" />"	Param: 'target' -> Annotation: 'SaQCFields | NewSaQCFields | None' -> is_union_type -> conditional
saqc.funcs.flagtools	squeeze	bool	"<param type=""boolean"" argument=""squeeze"" label=""squeeze"" help=""Squeeze the history into a single column if ``True``, function specific flag information is lost"" checked=""false"" truevalue=""squeeze"" falsevalue="""" />"	Param: 'squeeze' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.flagtools	overwrite	bool	"<param type=""boolean"" argument=""overwrite"" label=""Overwrite existing flags if ``True``"" help=""Overwrite existing flags if ``True``"" checked=""false"" truevalue=""overwrite"" falsevalue="""" />"	Param: 'overwrite' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.generic	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.generic	func	GenericFunction	"<param type=""text"" argument=""func"" label=""Function to call"" help=""The function needs to accept the same number of arguments (of type pandas.Series) as variables given in ``field`` and return an iterable of array-like objects of data type ``bool`` with the same length as ``target``"" />"	Param: 'func' -> Annotation: 'GenericFunction' -> is_simple_type
saqc.funcs.generic	target	SaQCFields | NewSaQCFields | None	"<conditional name=""target_cond"" label=""target"" />"	Param: 'target' -> Annotation: 'SaQCFields | NewSaQCFields | None' -> is_union_type -> conditional
saqc.funcs.generic	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.generic	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.generic	func	GenericFunction	"<param type=""text"" argument=""func"" label=""Function to call on the variables given in ``field``"" help=""The return value will be written to ``target`` or ``field`` if the former is not given. This implies, that the function needs to accept the same number of arguments (of type pandas.Series) as variables given in ``field`` and should return an iterable of array-like objects with the same number of elements as given in ``target`` (or ``field`` if ``target`` is not specified)"" />"	Param: 'func' -> Annotation: 'GenericFunction' -> is_simple_type
saqc.funcs.generic	target	SaQCFields | NewSaQCFields | None	"<conditional name=""target_cond"" label=""target"" />"	Param: 'target' -> Annotation: 'SaQCFields | NewSaQCFields | None' -> is_union_type -> conditional
saqc.funcs.generic	dfilter	float	"<param type=""float"" argument=""dfilter"" label=""dfilter"" help="":py:class:`Any`, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme"" optional=""true"" value=""-inf"" />"	Param: 'dfilter' -> Annotation: 'float' -> is_simple_type
saqc.funcs.interpolation	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.interpolation	freq	Union[FreqStr, int]	"<conditional name=""freq_cond"" label=""Target frequency"" />"	Param: 'freq' -> Annotation: 'Union[FreqStr, int]' -> is_union_type -> conditional
saqc.funcs.interpolation	method	str	"<param type=""text"" argument=""method"" label=""Interpolation technique to use"" help=""One of:  * ``'nshift'``: Shift grid points to the nearest time stamp in the range = +/- 0.5 * ``freq``. * ``'bshift'``: Shift grid points to the first succeeding time stamp (if any). * ``'fshift'``: Shift grid points to the last preceeding time stamp (if any). * ``'linear'``: Ignore the index and treat the values as equally spaced. * ``'time'``, ``'index'``, ``'values'``: Use the actual numerical values of the index. * ``'pad'``: Fill in NaNs using existing values. * ``'spline'``, ``'polynomial'``: Passed to ``scipy.interpolate.interp1d``. These methods use the numerical values of the index.  An ``order`` must be specified, e.g. ``qc.interpolate(method='polynomial', order=5)``. * ``'nearest'``, ``'zero'``, ``'slinear'``, ``'quadratic'``, ``'cubic'``, ``'barycentric'``: Passed to ``scipy.interpolate.interp1d``. These methods use the numerical values of the index. * ``'krogh'``, ``'spline'``, ``'pchip'``, ``'akima'``, ``'cubicspline'``: Wrappers around the SciPy interpolation methods of similar names. * ``'from_derivatives'``: Refers to ``scipy.interpolate.BPoly.from_derivatives``"" optional=""true"" value=""time"" />"	Param: 'method' -> Annotation: 'str' -> is_simple_type
saqc.funcs.interpolation	order	Int > 0	"<param type=""integer"" argument=""order"" label=""order"" help=""Order of the interpolation method, ignored if not supported by the chosen ``method``"" optional=""true"" value=""2"" min=""0"" />"	Param: 'order' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.interpolation	overwrite	bool	"<param type=""boolean"" argument=""overwrite"" label=""If set to `True`, existing flags will be cleared"" help=""If set to `True`, existing flags will be cleared"" checked=""false"" truevalue=""overwrite"" falsevalue="""" />"	Param: 'overwrite' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.interpolation	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.interpolation	window	OffsetStr | (Int > 0)	"<conditional name=""window_cond"" label=""The size of the window, the aggregation is computed from"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int > 0)' -> is_union_type -> conditional
saqc.funcs.interpolation	func	Callable[[pd.Series], float] | str	"<conditional name=""func_cond"" label=""func"" />"	Param: 'func' -> Annotation: 'Callable[[pd.Series], float] | str' -> is_union_type -> conditional
saqc.funcs.interpolation	center	bool	"<param type=""boolean"" argument=""center"" label=""Center the window around the value"" help=""Can only be used with integer windows, otherwise it is silently ignored"" checked=""false"" truevalue=""center"" falsevalue="""" />"	Param: 'center' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.interpolation	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of valid (not np.nan) values that have to be available in a window for its aggregation to be computed"" optional=""true"" value=""0"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.interpolation	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""-inf"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.noise	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.noise	window	OffsetStr | pd.Timedelta	"<conditional name=""window_cond"" label=""window"" />"	Param: 'window' -> Annotation: 'OffsetStr | pd.Timedelta' -> is_union_type -> conditional
saqc.funcs.noise	thresh	Float >= 0	"<param type=""float"" argument=""thresh"" label=""thresh"" help=""Threshold. A given chunk is flagged, if the return value of ``func`` excceeds ``thresh``"" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.noise	func	Literal['std', 'var', 'mad'] | Callable[[np.ndarray, pd.Series], float]	"<conditional name=""func_cond"" label=""func"" />"	Param: 'func' -> Annotation: 'Literal['std', 'var', 'mad'] | Callable[[np.ndarray, pd.Series], float]' -> is_union_type -> conditional
saqc.funcs.noise	sub_window	OffsetStr | pd.Timedelta | None	"<conditional name=""sub_window_cond"" label=""sub_window"" />"	Param: 'sub_window' -> Annotation: 'OffsetStr | pd.Timedelta | None' -> is_union_type -> conditional
saqc.funcs.noise	sub_thresh	(Float >= 0) | None	"<param type=""float"" argument=""sub_thresh"" label=""sub_thresh"" help=""Threshold. A given sub chunk is flagged, if the return value of ``func` excceeds ``sub_thresh``"" optional=""true"" min=""0"" />"	Param: 'sub_thresh' -> Annotation: '(Float >= 0) | None' -> is_simple_type
saqc.funcs.noise	min_periods	(Int >= 0) | None	"<param type=""integer"" argument=""min_periods"" label=""Minimum number of values needed in a chunk to perfom the test"" help=""Ignored if ``window`` is an integer"" optional=""true"" min=""0"" />"	Param: 'min_periods' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.noise	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.noise	field	str	"<param type=""text"" argument=""field"" label=""field"" help="""" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.noise	window	OffsetStr	"<param type=""text"" argument=""window"" label=""window"" help="""" />"	Param: 'window' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.noise	thresh	Float >= 0	"<param type=""float"" argument=""thresh"" label=""thresh"" help="""" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.noise	func	Literal['std', 'var', 'mad'] | Callable[[np.ndarray, pd.Series], float]	"<conditional name=""func_cond"" label=""func"" />"	Param: 'func' -> Annotation: 'Literal['std', 'var', 'mad'] | Callable[[np.ndarray, pd.Series], float]' -> is_union_type -> conditional
saqc.funcs.noise	sub_window	(Float > 0) | OffsetStr | None	"<conditional name=""sub_window_cond"" label=""sub_window"" />"	Param: 'sub_window' -> Annotation: '(Float > 0) | OffsetStr | None' -> is_union_type -> conditional
saqc.funcs.noise	sub_thresh	(Float > 0) | None	"<param type=""float"" argument=""sub_thresh"" label=""sub_thresh"" help="""" optional=""true"" min=""0"" />"	Param: 'sub_thresh' -> Annotation: '(Float > 0) | None' -> is_simple_type
saqc.funcs.noise	min_periods	(Int >= 0) | None	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help="""" optional=""true"" min=""0"" />"	Param: 'min_periods' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.noise	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="""" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.outliers	window	FreqStr | (Int >= 0)	"<conditional name=""window_cond"" label=""Size of the testing window"" />"	Param: 'window' -> Annotation: 'FreqStr | (Int >= 0)' -> is_union_type -> conditional
saqc.funcs.outliers	alpha	Float[0, 1]	"<param type=""float"" argument=""alpha"" label=""Level of significance, the grubbs test is to be performed at"" help=""Must be between 0 and 1"" optional=""true"" value=""0.05"" min=""0"" max=""1"" />"	Param: 'alpha' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.outliers	min_periods	Int >= 1	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of values needed in a `window` in order to perform the grubs test. Ignored if `window` is an integer"" optional=""true"" value=""8"" min=""1"" />"	Param: 'min_periods' -> Annotation: 'Int >= 1' -> is_simple_type
saqc.funcs.outliers	pedantic	bool	"<param type=""boolean"" argument=""pedantic"" label=""If ``True``, every value gets checked twice"" help=""First in the initial rolling `window` and second in a rolling window that is lagging by `window` / 2. Recommended to avoid false positives at the window edges. Ignored if `window` is an offset string"" checked=""false"" truevalue=""pedantic"" falsevalue="""" />"	Param: 'pedantic' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.outliers	window	OffsetStr | (Int >= 1) | None	"<conditional name=""window_cond"" label=""window"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int >= 1) | None' -> is_union_type -> conditional
saqc.funcs.outliers	min_periods	Int >= 1	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of periods per partition that have to be present for a valid outlier detection to be made in this partition"" optional=""true"" value=""11"" min=""1"" />"	Param: 'min_periods' -> Annotation: 'Int >= 1' -> is_simple_type
saqc.funcs.outliers	iter_start	Float[0, 1]	"<param type=""float"" argument=""iter_start"" label=""iter_start"" help=""Float in ``[0, 1]`` that determines which percentage of data is considered  normal . ``0.5`` results in the stray algorithm to search only the upper 50% of the scores for the cut off point. (See reference section for more information)"" optional=""true"" value=""0.5"" min=""0"" max=""1"" />"	Param: 'iter_start' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.outliers	alpha	Float[0, 1]	"<param type=""float"" argument=""alpha"" label=""alpha"" help=""Level of significance by which it is tested, if a score might be drawn from another distribution than the majority of the data"" optional=""true"" value=""0.05"" min=""0"" max=""1"" />"	Param: 'alpha' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	str | Sequence[str]	"<conditional name=""field_cond"" label=""Variable to process"" />"	Param: 'field' -> Annotation: 'str | Sequence[str]' -> is_union_type -> conditional
saqc.funcs.outliers	n	Int > 0	"<param type=""integer"" argument=""n"" label=""Number of neighbors to be included into the LOF calculation"" help=""Defaults to ``20``, which is a value found to be suitable in the literature.  * `n` determines the  locality  of an observation (its `n` nearest neighbors) and sets the upper limit to the number of values in outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n`/2 may not be detected reliably. * The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outliers points. Higher values greatly increase numerical costs"" optional=""true"" value=""20"" min=""0"" />"	Param: 'n' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.outliers	thresh	Literal['auto'] | (Float >= 1)	"<conditional name=""thresh_cond"" label=""The threshold for flagging the calculated LOF"" />"	Param: 'thresh' -> Annotation: 'Literal['auto'] | (Float >= 1)' -> is_union_type -> conditional
saqc.funcs.outliers	algorithm	Literal['ball_tree', 'kd_tree', 'brute', 'auto']	"<param type=""select"" argument=""algorithm"" label=""Algorithm used for calculating the `n`-nearest neighbors"" help=""Algorithm used for calculating the `n`-nearest neighbors"" optional=""true"" value=""ball_tree"" />"	Param: 'algorithm' -> Annotation: 'Literal['ball_tree', 'kd_tree', 'brute', 'auto']' -> is_simple_type
saqc.funcs.outliers	p	Int > 0	"<param type=""integer"" argument=""p"" label=""p"" help=""Degree of the metric ( Minkowski ), according to which the distance to neighbors is determined. Most important values are:  * ``1`` - Manhattan Metric * ``2`` - Euclidian Metric"" optional=""true"" value=""1"" min=""0"" />"	Param: 'p' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.outliers	window	FreqStr | (Int >= 0) | None	"<conditional name=""window_cond"" label=""Size of the window"" />"	Param: 'window' -> Annotation: 'FreqStr | (Int >= 0) | None' -> is_union_type -> conditional
saqc.funcs.outliers	z	Float >= 0	"<param type=""float"" argument=""z"" label=""The value the Z-score is tested against"" help=""Defaulting to ``3.5`` (Recommendation of [1])"" optional=""true"" value=""3.5"" min=""0"" />"	Param: 'z' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.outliers	min_residuals	(Int >= 0) | None	"<param type=""integer"" argument=""min_residuals"" label=""min_residuals"" help="""" optional=""true"" min=""0"" />"	Param: 'min_residuals' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.outliers	min_periods	(Int >= 0) | None	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of valid meassurements in a scoring window, to consider the resulting score valid"" optional=""true"" min=""0"" />"	Param: 'min_periods' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.outliers	center	bool	"<param type=""boolean"" argument=""center"" label=""Weather or not to center the target value in the scoring window"" help=""If ``False``, the target value is the last value in the window"" checked=""false"" truevalue=""center"" falsevalue="""" />"	Param: 'center' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	Sequence[str]	"<param type=""text"" argument=""field"" label=""List of variables names to process"" help=""List of variables names to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'Sequence[str]' -> is_simple_type
saqc.funcs.outliers	trafo	Callable[[pd.Series], pd.Series]	"<param type=""text"" argument=""trafo"" label=""Transformation to be applied onto every column before scoring"" help=""For more fine-grained control, the data could also be transformed before :py:meth:`~saqc.SaQC.flagMVScores` is called"" optional=""true"" />"	Param: 'trafo' -> Annotation: 'Callable[[pd.Series], pd.Series]' -> is_simple_type
saqc.funcs.outliers	alpha	Float[0, 1]	"<param type=""float"" argument=""alpha"" label=""alpha"" help=""Level of significance by which it is tested, if an observations score might be drawn from another distribution than the majority of the data"" optional=""true"" value=""0.05"" min=""0"" max=""1"" />"	Param: 'alpha' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.outliers	n	Int >= 1	"<param type=""integer"" argument=""n"" label=""Number of neighbors included in the scoring process for every datapoint"" help=""Number of neighbors included in the scoring process for every datapoint"" optional=""true"" value=""10"" min=""1"" />"	Param: 'n' -> Annotation: 'Int >= 1' -> is_simple_type
saqc.funcs.outliers	func	Callable[[pd.Series], float] | str	"<conditional name=""func_cond"" label=""func"" />"	Param: 'func' -> Annotation: 'Callable[[pd.Series], float] | str' -> is_union_type -> conditional
saqc.funcs.outliers	iter_start	Float[0, 1]	"<param type=""float"" argument=""iter_start"" label=""iter_start"" help=""Value in ``[0,1]`` that determines which percentage of data is considered  normal . 0.5 results in the threshing algorithm to search only the upper 50% of the scores for the cut-off point. (See reference section for more information)"" optional=""true"" value=""0.5"" min=""0"" max=""1"" />"	Param: 'iter_start' -> Annotation: 'Float[0, 1]' -> is_simple_type
saqc.funcs.outliers	window	(Int >= 1) | OffsetStr	"<conditional name=""window_cond"" label=""Only effective if `threshing` is set to ``'stray'``"" />"	Param: 'window' -> Annotation: '(Int >= 1) | OffsetStr' -> is_union_type -> conditional
saqc.funcs.outliers	min_periods	Int > 1	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Only effective if `threshing` is set to ``'stray'`` and `partition` is an integer. Minimum number of periods per `partition` that have to be present for a valid outlier detection to be made in this partition"" optional=""true"" value=""11"" min=""1"" />"	Param: 'min_periods' -> Annotation: 'Int > 1' -> is_simple_type
saqc.funcs.outliers	stray_range	OffsetStr	"<param type=""text"" argument=""stray_range"" label=""stray_range"" help=""If not ``None``, it is tried to reduce the stray result onto single outlier components of the input `field`. The offset string denotes the range of the temporal surrounding to include into the MAD testing while trying to reduce flags"" optional=""true"" />"	Param: 'stray_range' -> Annotation: 'OffsetStr' -> is_simple_type
saqc.funcs.outliers	drop_flagged	bool	"<param type=""boolean"" argument=""drop_flagged"" label=""Only effective when `stray_range` is not ``None``"" help=""Whether or not to drop flagged values from the temporal surroundings"" checked=""false"" truevalue=""drop_flagged"" falsevalue="""" />"	Param: 'drop_flagged' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.outliers	thresh	Float >= 0	"<param type=""float"" argument=""thresh"" label=""Only effective when `stray_range` is not ``None``"" help=""The 'critical' value, controlling wheather the MAD score is considered referring to an outlier or not. Higher values result in less rigid flagging. The default value is widely considered apropriate in the literature"" optional=""true"" value=""3.5"" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.outliers	min_periods_r	Int >= 1	"<param type=""integer"" argument=""min_periods_r"" label=""Only effective when `stray_range` is not ``None``"" help=""Minimum number of measurements necessary in an interval to actually perform the reduction step"" optional=""true"" value=""1"" min=""1"" />"	Param: 'min_periods_r' -> Annotation: 'Int >= 1' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.outliers	tolerance	Float >= 0	"<param type=""float"" argument=""tolerance"" label=""tolerance"" help=""Maximum difference allowed between the value, directly preceding and the value directly succeeding an offset to trigger flagging of the offsetting values. See condition (4)"" min=""0"" />"	Param: 'tolerance' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.outliers	window	FreqStr	"<param type=""text"" argument=""window"" label=""window"" help=""Maximum length allowed for offset value courses, to trigger flagging of the offsetting values. See condition (5). Integer defined window length are only allowed for regularly sampled timeseries"" />"	Param: 'window' -> Annotation: 'FreqStr' -> is_simple_type
saqc.funcs.outliers	thresh	(Float > 0) | None	"<param type=""float"" argument=""thresh"" label=""thresh"" help=""Minimum difference between a value and its successors, to consider the successors an anomalous offset group. See condition (1). If ``None``, condition (1) is not tested"" optional=""true"" min=""0"" />"	Param: 'thresh' -> Annotation: '(Float > 0) | None' -> is_simple_type
saqc.funcs.outliers	thresh_relative	float | None	"<param type=""float"" argument=""thresh_relative"" label=""thresh_relative"" help=""Minimum relative change between a value and its successors, to consider the successors an anomalous offset group. See condition (2). If ``None``, condition (2) is not tested"" optional=""true"" />"	Param: 'thresh_relative' -> Annotation: 'float | None' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.outliers	thresh	float	"<param type=""float"" argument=""thresh"" label=""thresh"" help=""The threshold, for the total rise (`thresh` ``  0``), or total drop (`thresh` ``  0``), value courses must not exceed within a timespan of length `raise_window`"" />"	Param: 'thresh' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	raise_window	FreqStr	"<param type=""text"" argument=""raise_window"" label=""raise_window"" help=""An offset string, determining the timespan, the rise/drop thresholding refers to. Window is inclusively defined"" />"	Param: 'raise_window' -> Annotation: 'FreqStr' -> is_simple_type
saqc.funcs.outliers	freq	FreqStr	"<param type=""text"" argument=""freq"" label=""freq"" help=""An offset string, determining the frequency, the timeseries to flag is supposed to be sampled at. The window is inclusively defined"" />"	Param: 'freq' -> Annotation: 'FreqStr' -> is_simple_type
saqc.funcs.outliers	average_window	FreqStr | None	"<param type=""text"" argument=""average_window"" label=""See condition (2) of the description given in the Notes"" help=""Window is inclusively defined, defaults to 1.5 times the size of `raise_window`"" optional=""true"" />"	Param: 'average_window' -> Annotation: 'FreqStr | None' -> is_simple_type
saqc.funcs.outliers	raise_factor	Float >= 1	"<param type=""float"" argument=""raise_factor"" label=""See condition (2)"" help=""See condition (2)"" optional=""true"" value=""2.0"" min=""1"" />"	Param: 'raise_factor' -> Annotation: 'Float >= 1' -> is_simple_type
saqc.funcs.outliers	slope	(Float >= 0) | None	"<param type=""float"" argument=""slope"" label=""See condition (3)"" help=""See condition (3)"" optional=""true"" min=""0"" />"	Param: 'slope' -> Annotation: '(Float >= 0) | None' -> is_simple_type
saqc.funcs.outliers	weight	Float >= 0	"<param type=""float"" argument=""weight"" label=""See condition (3)"" help=""See condition (3)"" optional=""true"" value=""0.8"" min=""0"" />"	Param: 'weight' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.outliers	min	float	"<param type=""float"" argument=""min"" label=""Lower bound for valid data"" help=""Lower bound for valid data"" optional=""true"" value=""-inf"" />"	Param: 'min' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	max	float	"<param type=""float"" argument=""max"" label=""Upper bound for valid data"" help=""Upper bound for valid data"" optional=""true"" value=""inf"" />"	Param: 'max' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.outliers	n	Int > 0	"<param type=""integer"" argument=""n"" label=""Number of periods to be included into the LOF calculation"" help=""Defaults to `20`, which is a value found to be suitable in the literature.  * `n` determines the  locality  of an observation (its `n` nearest neighbors) and sets the upper limit to the number of values in an outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n`/2 may not be detected reliably. * The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outlier points. Higher values greatly increase numerical costs"" optional=""true"" value=""20"" min=""0"" />"	Param: 'n' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.outliers	thresh	Literal['auto'] | (Float >= 0) | None	"<conditional name=""thresh_cond"" label=""Outlier Factor Cutoff"" />"	Param: 'thresh' -> Annotation: 'Literal['auto'] | (Float >= 0) | None' -> is_union_type -> conditional
saqc.funcs.outliers	probability	Float[0, 1] | None	"<param type=""float"" argument=""probability"" label=""probability"" help=""Outlier probability cutoff  * If given, compute local outlier probabilities and cut them off at value level `probability`, resulting in all values with factors larger than the cutoff, being flagged"" optional=""true"" min=""0"" max=""1"" />"	Param: 'probability' -> Annotation: 'Float[0, 1] | None' -> is_simple_type
saqc.funcs.outliers	corruption	Float[0, 1] | (Int > 0) | None	"<conditional name=""corruption_cond"" label=""Portion of data that is anomalous"" />"	Param: 'corruption' -> Annotation: 'Float[0, 1] | (Int > 0) | None' -> is_union_type -> conditional
saqc.funcs.outliers	algorithm	Literal['ball_tree', 'kd_tree', 'brute', 'auto']	"<param type=""select"" argument=""algorithm"" label=""algorithm"" help=""Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation"" optional=""true"" value=""ball_tree"" />"	Param: 'algorithm' -> Annotation: 'Literal['ball_tree', 'kd_tree', 'brute', 'auto']' -> is_simple_type
saqc.funcs.outliers	p	Int > 0	"<param type=""integer"" argument=""p"" label=""p"" help=""Degree of the metric ( Minkowski ), according to which distance to neighbors is determined. Most important values are:  * ``1`` - Manhatten Metric * ``2`` - Euclidian Metric"" optional=""true"" value=""1"" min=""0"" />"	Param: 'p' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.outliers	density	Literal['auto'] | (Float > 0)	"<conditional name=""density_cond"" label=""How to calculate the temporal distance/density for the variable to flag"" />"	Param: 'density' -> Annotation: 'Literal['auto'] | (Float > 0)' -> is_union_type -> conditional
saqc.funcs.outliers	fill_na	bool	"<param type=""boolean"" argument=""fill_na"" label=""If True, NaNs in the data are filled with a linear interpolation"" help=""If True, NaNs in the data are filled with a linear interpolation"" checked=""false"" truevalue=""fill_na"" falsevalue="""" />"	Param: 'fill_na' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.outliers	slope_correct	bool	"<param type=""boolean"" argument=""slope_correct"" label=""slope_correct"" help=""if True, a correction is applied, that removes outlier cluster that actually just seem to be steep slopes"" checked=""false"" truevalue=""slope_correct"" falsevalue="""" />"	Param: 'slope_correct' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.outliers	min_offset	(Float > 0) | None	"<param type=""float"" argument=""min_offset"" label=""min_offset"" help=""If set, only those outlier cluster will be flagged, that are preceeded and succeeeded by sufficiently large value  jumps . Defaults to estimating the sufficient value jumps from the median over the absolute step sizes between data points"" optional=""true"" min=""0"" />"	Param: 'min_offset' -> Annotation: '(Float > 0) | None' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.outliers	field	SaQCFields	"<param type=""text"" argument=""field"" label=""List of variables names to process"" help=""List of variables names to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.outliers	method	Literal['standard', 'modified']	"<param type=""select"" argument=""method"" label=""method"" help=""Which method to use for ZScoring:  * ` standard `: standard Zscoring, using *mean* for the expectation and *standard deviation (std)* as scaling factor * ` modified `: modified Zscoring, using *median* as the expectation and *median absolute deviation (MAD)* as the scaling Factor  See notes section for detailed scoring formula"" optional=""true"" value=""standard"" />"	Param: 'method' -> Annotation: 'Literal['standard', 'modified']' -> is_simple_type
saqc.funcs.outliers	window	FreqStr | (Int >= 0) | None	"<conditional name=""window_cond"" label=""Size of the window"" />"	Param: 'window' -> Annotation: 'FreqStr | (Int >= 0) | None' -> is_union_type -> conditional
saqc.funcs.outliers	thresh	Float > 0	"<param type=""float"" argument=""thresh"" label=""thresh"" help=""Cutoff level for the Zscores, above which associated points are marked as outliers"" optional=""true"" value=""3"" min=""0"" />"	Param: 'thresh' -> Annotation: 'Float > 0' -> is_simple_type
saqc.funcs.outliers	min_residuals	(Float >= 0) | None	"<param type=""float"" argument=""min_residuals"" label=""Minimum residual value points must have to be considered outliers"" help=""Minimum residual value points must have to be considered outliers"" optional=""true"" min=""0"" />"	Param: 'min_residuals' -> Annotation: '(Float >= 0) | None' -> is_simple_type
saqc.funcs.outliers	min_periods	(Int > 0) | None	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of valid meassurements in a scoring window, to consider the resulting score valid"" optional=""true"" min=""0"" />"	Param: 'min_periods' -> Annotation: '(Int > 0) | None' -> is_simple_type
saqc.funcs.outliers	center	bool	"<param type=""boolean"" argument=""center"" label=""Weather or not to center the target value in the scoring window"" help=""If ``False``, the target value is the last value in the window"" checked=""false"" truevalue=""center"" falsevalue="""" />"	Param: 'center' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.outliers	axis	Int[0, 1]	"<param type=""integer"" argument=""axis"" label=""axis"" help=""Along which axis to calculate the scoring statistics:  * `0` (default) - calculate statistics along time axis * `1` - calculate statistics over multiple variables  See Notes section for a visual clarification of the workings of `axis` and `window`"" optional=""true"" value=""0"" min=""0"" max=""1"" />"	Param: 'axis' -> Annotation: 'Int[0, 1]' -> is_simple_type
saqc.funcs.outliers	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.pattern	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.pattern	reference	str	"<param type=""text"" argument=""reference"" label=""The name in `data` which holds the pattern"" help=""The pattern must not have NaNs, have a datetime index and must not be empty"" />"	Param: 'reference' -> Annotation: 'str' -> is_simple_type
saqc.funcs.pattern	max_distance	Float >= 0	"<param type=""float"" argument=""max_distance"" label=""max_distance"" help=""Maximum dtw-distance between chunk and pattern, if the distance is lower than ``max_distance`` the data gets flagged. With default, ``0.0``, only exact matches are flagged"" optional=""true"" value=""0.0"" min=""0"" />"	Param: 'max_distance' -> Annotation: 'Float >= 0' -> is_simple_type
saqc.funcs.pattern	normalize	bool	"<param type=""boolean"" argument=""normalize"" label=""If `False`, return unmodified distances"" help=""If `True`, normalize distances by the number of observations of the reference. This helps to make it easier to find a good cutoff threshold for further processing. The distances then refer to the mean distance per datapoint, expressed in the datas units"" checked=""false"" truevalue=""normalize"" falsevalue="""" />"	Param: 'normalize' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.pattern	plot	bool	"<param type=""boolean"" argument=""plot"" label=""plot"" help=""Show a calibration plot, which can be quite helpful to find the right threshold for `max_distance`. It works best with `normalize=True`. Do not use in automatic setups / pipelines. The plot show three lines:  - data: the data the function was called on - distances: the calculated distances by the algorithm - indicator: have to distinct levels: `0` and the value of `max_distance`. If `max_distance` is `0.0` it defaults to `1`. Everywhere where the indicator is not `0` the data will be flagged"" checked=""false"" truevalue=""plot"" falsevalue="""" />"	Param: 'plot' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.pattern	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.pattern	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.pattern	min_length	(Int > 0) | OffsetStr	"<conditional name=""min_length_cond"" label=""Minimum temporal extension of value course to qualify as plateau"" />"	Param: 'min_length' -> Annotation: '(Int > 0) | OffsetStr' -> is_union_type -> conditional
saqc.funcs.pattern	max_length	(Int > 0) | OffsetStr | None	"<conditional name=""max_length_cond"" label=""max_length"" />"	Param: 'max_length' -> Annotation: '(Int > 0) | OffsetStr | None' -> is_union_type -> conditional
saqc.funcs.pattern	min_jump	(Float >= 0) | None	"<param type=""float"" argument=""min_jump"" label=""min_jump"" help=""minimum margin anomalies/plateaus have to differ from directly preceding and succeeding periods. If ``None`` (default), the minimum jump threshold will be derived automatically from the median of the local absolute difference between any two periods in the vicinity of any potential anomaly"" optional=""true"" min=""0"" />"	Param: 'min_jump' -> Annotation: '(Float >= 0) | None' -> is_simple_type
saqc.funcs.pattern	granularity	(Int > 0) | OffsetStr | None	"<conditional name=""granularity_cond"" label=""granularity"" />"	Param: 'granularity' -> Annotation: '(Int > 0) | OffsetStr | None' -> is_union_type -> conditional
saqc.funcs.pattern	flag	float	"<param type=""float"" argument=""flag"" label=""flag"" help="":py:class:`Any`, optional The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'flag' -> Annotation: 'float' -> is_simple_type
saqc.funcs.resampling	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.resampling	target	str | None	"<param type=""text"" argument=""target"" label=""target"" help="":py:class:`SaQCFields` | :py:class:`newSaQCFields` Variable name to which the results are written. `target` will be created if it does not exist. Defaults to `field`"" optional=""true"" />"	Param: 'target' -> Annotation: 'str | None' -> is_simple_type
saqc.funcs.resampling	method	Literal['fagg', 'bagg', 'nagg', 'fshift', 'bshift', 'nshift', 'sshift', 'mshift', 'match', 'auto', 'linear', 'pad']	"<param type=""select"" argument=""method"" label=""method"" help=""Method to project the flags of `field` to the flags to `target`:  * ``'auto'``: invert the last alignment/resampling operation (that is not already inverted) * ``'nagg'``: project a flag of `field` to all timestamps of `target` within the range +/- `freq`/2. * ``'bagg'``: project a flag of `field` to all preceeding timestamps of `target` within the range `freq` * ``'fagg'``: project a flag of `field` to all succeeding timestamps of `target` within the range `freq` * ``'interpolation'`` - project a flag of `field` to all timestamps of `target` within the range +/- `freq` * ``'sshift'`` - same as interpolation * ``'nshift'`` - project a flag of `field` to the neaerest timestamps in `target` within the range +/- `freq`/2 * ``'bshift'`` - project a flag of `field` to nearest preceeding timestamps in `target` * ``'nshift'`` - project a flag of `field` to nearest succeeding timestamps in `target` * ``'match'`` - project a flag of `field` to all identical timestamps `target`"" optional=""true"" value=""auto"" />"	Param: 'method' -> Annotation: 'Literal['fagg', 'bagg', 'nagg', 'fshift', 'bshift', 'nshift', 'sshift', 'mshift', 'match', 'auto', 'linear', 'pad']' -> is_simple_type
saqc.funcs.resampling	invert	bool	"<param type=""boolean"" argument=""invert"" label=""If True, not the actual method is applied, but its inversion-method"" help=""If True, not the actual method is applied, but its inversion-method"" checked=""false"" truevalue=""invert"" falsevalue="""" />"	Param: 'invert' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.resampling	freq	FreqStr | pd.Timedelta | None	"<conditional name=""freq_cond"" label=""Projection range"" />"	Param: 'freq' -> Annotation: 'FreqStr | pd.Timedelta | None' -> is_union_type -> conditional
saqc.funcs.resampling	drop	bool	"<param type=""boolean"" argument=""drop"" label=""Remove `field` if ``True``"" help=""Remove `field` if ``True``"" checked=""false"" truevalue=""drop"" falsevalue="""" />"	Param: 'drop' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.resampling	squeeze	bool	"<param type=""boolean"" argument=""squeeze"" label=""squeeze"" help=""Squeeze the history into a single column if ``True``, function specific flag information is lost"" checked=""false"" truevalue=""squeeze"" falsevalue="""" />"	Param: 'squeeze' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.resampling	override	bool	"<param type=""boolean"" argument=""override"" label=""Overwrite existing flags if ``True``"" help=""Overwrite existing flags if ``True``"" checked=""false"" truevalue=""override"" falsevalue="""" />"	Param: 'override' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.resampling	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.resampling	index	FreqStr | pd.DatetimeIndex | str	"<conditional name=""index_cond"" label=""Determines the new index"" />"	Param: 'index' -> Annotation: 'FreqStr | pd.DatetimeIndex | str' -> is_union_type -> conditional
saqc.funcs.resampling	method	METHOD_LITERALS	"<param type=""select"" argument=""method"" label=""method"" help=""Determines which of the origins indexes periods to comprise into the calculation of a new flag and a new data value at any period of the new index.  * Aggregations Reindexer. Aggregations are data and flags independent, (pure) index selection methods: * `'bagg'`/`'fagg'`:  backwards/forwards aggregation . Any new index period gets assigned an aggregation of the values at periods in the original index, that lie between itself and its successor/predecessor. * `'nagg'`:  nearest aggregation : Any new index period gets assigned an aggregation of the values at periods in the original index between its direcet predecessor and successor, it is the nearest neighbor to. * Rolling reindexer. Rolling reindexers are equal to aggregations, when projecting between regular and irregular sampling grids forth and back. But due to there simple rolling window construction, they are easier to comprehend, predict and parametrize. On the downside, they are much more expensive computationally and Also, periods can get included in the aggregation to multpiple target periods, (when rolling windows overlap). * `'broll'`/`'froll'`: Any new index period gets assigned an aggregation of all the values at periods of the original index, that fall into a directly preceeding/succeeding window of size `reindex_window`. * Shifts. Shifting methods are shortcuts for aggregation reindex methods, combined with selecting 'last' or 'first' as the `data_aggregation` method. Therefor, both, the `flags_aggregation` and the `data_aggregation` are ignored when using a `shift` reindexer. Also, periods where the data evaluates to `NaN` are dropped before shift index selection. * `'bshift'`/`fshift`:  backwards/forwards shift . Any new index period gets assigned the first/last valid (not a data NaN) value it succeeds/preceeds * `'nshift'`:  nearest shift : Any new index period gets assigned the value of its closest neighbor in the original index. * Pillar point Mappings. Index selection method designed to select indices suitable for linearly interpolating index values from surrounding pillar points in the original index, or inverting such a selection. Periods where the data evaluates to `NaN`, are dropped from consideration. * `'mshift'`:  Merge  predecessors and successors. Any new index period gets assigned an aggregation/interpolation comprising the last and the next valid period in the original index. * `'sshift'`:  Split -map values onto predecessors and successors. Same as `mshift`, but with a correction that prevents missing value flags from being mapped to continuous data chunk bounds. * Inversion of last method: try to select the method, that * `'invert``"" optional=""true"" value=""match"" />"	Param: 'method' -> Annotation: 'METHOD_LITERALS' -> is_simple_type
saqc.funcs.resampling	tolerance	OffsetStr | OffsetLike | None	"<conditional name=""tolerance_cond"" label=""Limiting the distance, values can be shifted or comprised into aggregation"" />"	Param: 'tolerance' -> Annotation: 'OffsetStr | OffsetLike | None' -> is_union_type -> conditional
saqc.funcs.resampling	data_aggregation	AGG_FUNC_LITERALS | Callable | float | None	"<conditional name=""data_aggregation_cond"" label=""data_aggregation"" />"	Param: 'data_aggregation' -> Annotation: 'AGG_FUNC_LITERALS | Callable | float | None' -> is_union_type -> conditional
saqc.funcs.resampling	flags_aggregation	AGG_FUNC_LITERALS | Callable | float | None	"<conditional name=""flags_aggregation_cond"" label=""flags_aggregation"" />"	Param: 'flags_aggregation' -> Annotation: 'AGG_FUNC_LITERALS | Callable | float | None' -> is_union_type -> conditional
saqc.funcs.resampling	broadcast	bool	"<param type=""boolean"" argument=""broadcast"" label=""broadcast"" help=""Weather to propagate aggregation result to full reindex window when using aggregation reindexer. (as opposed to only assign to next/previous/closest)"" checked=""false"" truevalue=""broadcast"" falsevalue="""" />"	Param: 'broadcast' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.resampling	squeeze	bool	"<param type=""boolean"" argument=""squeeze"" label=""squeeze"" help="""" checked=""false"" truevalue=""squeeze"" falsevalue="""" />"	Param: 'squeeze' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.resampling	override	bool	"<param type=""boolean"" argument=""override"" label=""override"" help="""" checked=""false"" truevalue=""override"" falsevalue="""" />"	Param: 'override' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.resampling	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.resampling	freq	FreqStr | pd.Timedelta	"<conditional name=""freq_cond"" label=""Offset string"" />"	Param: 'freq' -> Annotation: 'FreqStr | pd.Timedelta' -> is_union_type -> conditional
saqc.funcs.resampling	func	Callable[[pd.Series], pd.Series] | str	"<conditional name=""func_cond"" label=""Aggregation function"" />"	Param: 'func' -> Annotation: 'Callable[[pd.Series], pd.Series] | str' -> is_union_type -> conditional
saqc.funcs.resampling	method	Literal['fagg', 'bagg', 'nagg']	"<param type=""select"" argument=""method"" label=""Specifies which intervals to be aggregated for a certain timestamp"" help=""(preceding, succeeding or  surrounding  interval). See description above for more details"" optional=""true"" value=""bagg"" />"	Param: 'method' -> Annotation: 'Literal['fagg', 'bagg', 'nagg']' -> is_simple_type
saqc.funcs.resampling	maxna	(Int >= 0) | None	"<param type=""integer"" argument=""maxna"" label=""Maximum number of allowed ``NaN``s in a resampling interval"" help=""If exceeded, the aggregation of the interval evaluates to ``NaN``"" optional=""true"" min=""0"" />"	Param: 'maxna' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.resampling	maxna_group	(Int >= 0) | None	"<param type=""integer"" argument=""maxna_group"" label=""Same as `maxna` but for consecutive NaNs"" help=""Same as `maxna` but for consecutive NaNs"" optional=""true"" min=""0"" />"	Param: 'maxna_group' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.resampling	squeeze	bool	"<param type=""boolean"" argument=""squeeze"" label=""squeeze"" help="""" checked=""false"" truevalue=""squeeze"" falsevalue="""" />"	Param: 'squeeze' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.residuals	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.residuals	window	OffsetStr | (Int > 0)	"<conditional name=""window_cond"" label=""The size of the window you want to use for fitting"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int > 0)' -> is_union_type -> conditional
saqc.funcs.residuals	order	int	"<param type=""integer"" argument=""order"" label=""The degree of the polynomial used for fitting"" help=""The degree of the polynomial used for fitting"" />"	Param: 'order' -> Annotation: 'int' -> is_simple_type
saqc.funcs.residuals	min_periods	int	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""The minimum number of periods, that has to be available in every values fitting surrounding for the polynomial fit to be performed. If there are not enough values, np.nan gets assigned. Default (0) results in fitting regardless of the number of values present (results in overfitting for too sparse intervals). To automatically set the minimum number of periods to the number of values in an offset defined window size, pass np.nan"" optional=""true"" value=""0"" />"	Param: 'min_periods' -> Annotation: 'int' -> is_simple_type
saqc.funcs.residuals	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.residuals	window	OffsetStr | (Int > 0)	"<conditional name=""window_cond"" label=""The size of the window you want to roll with"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int > 0)' -> is_union_type -> conditional
saqc.funcs.residuals	func	Callable[[pd.Series], np.ndarray] | str	"<conditional name=""func_cond"" label=""func"" />"	Param: 'func' -> Annotation: 'Callable[[pd.Series], np.ndarray] | str' -> is_union_type -> conditional
saqc.funcs.residuals	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""The minimum number of periods to get a valid value"" help=""The minimum number of periods to get a valid value"" optional=""true"" value=""0"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.residuals	center	bool	"<param type=""boolean"" argument=""center"" label=""If True, center the rolling window"" help=""If True, center the rolling window"" checked=""false"" truevalue=""center"" falsevalue="""" />"	Param: 'center' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.rolling	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.rolling	window	OffsetStr | (Int > 0)	"<conditional name=""window_cond"" label=""The size of the window you want to roll with"" />"	Param: 'window' -> Annotation: 'OffsetStr | (Int > 0)' -> is_union_type -> conditional
saqc.funcs.rolling	target	SaQCFields | str | None	"<conditional name=""target_cond"" label=""target"" />"	Param: 'target' -> Annotation: 'SaQCFields | str | None' -> is_union_type -> conditional
saqc.funcs.rolling	func	Callable[[pd.Series], np.ndarray] | str	"<conditional name=""func_cond"" label=""func"" />"	Param: 'func' -> Annotation: 'Callable[[pd.Series], np.ndarray] | str' -> is_union_type -> conditional
saqc.funcs.rolling	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""The minimum number of periods to get a valid value"" help=""The minimum number of periods to get a valid value"" optional=""true"" value=""0"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.rolling	center	bool	"<param type=""boolean"" argument=""center"" label=""If True, center the rolling window"" help=""If True, center the rolling window"" checked=""false"" truevalue=""center"" falsevalue="""" />"	Param: 'center' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.scores	field	Sequence[str]	"<param type=""text"" argument=""field"" label=""List of variables names to process"" help=""List of variables names to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'Sequence[str]' -> is_simple_type
saqc.funcs.scores	target	str	"<param type=""text"" argument=""target"" label=""target"" help="":py:class:`SaQCFields` | :py:class:`newSaQCFields` Variable name to which the results are written. `target` will be created if it does not exist. Defaults to `field`"" />"	Param: 'target' -> Annotation: 'str' -> is_simple_type
saqc.funcs.scores	n	Int > 0	"<param type=""integer"" argument=""n"" label=""n"" help="": The number of nearest neighbors to which the distance is comprised in every datapoints scoring calculation"" optional=""true"" value=""10"" min=""0"" />"	Param: 'n' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.scores	func	Callable[[pd.Series], float] | str	"<conditional name=""func_cond"" label=""func"" />"	Param: 'func' -> Annotation: 'Callable[[pd.Series], float] | str' -> is_union_type -> conditional
saqc.funcs.scores	freq	(Float >= 0) | FreqStr	"<conditional name=""freq_cond"" label=""freq"" />"	Param: 'freq' -> Annotation: '(Float >= 0) | FreqStr' -> is_union_type -> conditional
saqc.funcs.scores	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""The minimum number of periods that have to be present in a window for the kNN scoring to be applied. If the number of periods present is below `min_periods`, the score for the datapoints in that window will be np.nan"" optional=""true"" value=""2"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.scores	algorithm	Literal['ball_tree', 'kd_tree', 'brute', 'auto']	"<param type=""select"" argument=""algorithm"" label=""The search algorithm to find each datapoints k nearest neighbors"" help=""The keyword just gets passed on to the underlying sklearn method. See reference [1] for more information on the algorithm"" optional=""true"" value=""ball_tree"" />"	Param: 'algorithm' -> Annotation: 'Literal['ball_tree', 'kd_tree', 'brute', 'auto']' -> is_simple_type
saqc.funcs.scores	metric	str	"<param type=""text"" argument=""metric"" label=""The metric the distances to any datapoints neighbors is computed with"" help=""The default of `metric` together with the default of `p` result in the euclidian to be applied. The keyword just gets passed on to the underlying sklearn method. See reference [1] for more information on the algorithm"" optional=""true"" value=""minkowski"" />"	Param: 'metric' -> Annotation: 'str' -> is_simple_type
saqc.funcs.scores	p	Int > 0	"<param type=""integer"" argument=""p"" label=""p"" help="": The grade of the metrice specified by parameter `metric`. The keyword just gets passed on to the underlying sklearn method. See reference [1] for more information on the algorithm"" optional=""true"" value=""2"" min=""0"" />"	Param: 'p' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.scores	field	Sequence[str]	"<param type=""text"" argument=""field"" label=""List of variables names to process"" help=""List of variables names to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'Sequence[str]' -> is_simple_type
saqc.funcs.scores	target	str	"<param type=""text"" argument=""target"" label=""target"" help="":py:class:`SaQCFields` | :py:class:`newSaQCFields` Variable name to which the results are written. `target` will be created if it does not exist. Defaults to `field`"" />"	Param: 'target' -> Annotation: 'str' -> is_simple_type
saqc.funcs.scores	n	Int > 0	"<param type=""integer"" argument=""n"" label=""Number of periods to be included into the LOF calculation"" help=""Defaults to `20`, which is a value found to be suitable in the literature"" optional=""true"" value=""20"" min=""0"" />"	Param: 'n' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.scores	freq	(Float > 0) | FreqStr	"<conditional name=""freq_cond"" label=""freq"" />"	Param: 'freq' -> Annotation: '(Float > 0) | FreqStr' -> is_union_type -> conditional
saqc.funcs.scores	min_periods	Int >= 0	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help="""" optional=""true"" value=""2"" min=""0"" />"	Param: 'min_periods' -> Annotation: 'Int >= 0' -> is_simple_type
saqc.funcs.scores	algorithm	Literal['ball_tree', 'kd_tree', 'brute', 'auto']	"<param type=""select"" argument=""algorithm"" label=""algorithm"" help=""Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation"" optional=""true"" value=""ball_tree"" />"	Param: 'algorithm' -> Annotation: 'Literal['ball_tree', 'kd_tree', 'brute', 'auto']' -> is_simple_type
saqc.funcs.scores	p	Int > 0	"<param type=""integer"" argument=""p"" label=""p"" help=""Degree of the metric ( Minkowski ), according to wich distance to neighbors is determined. Most important values are:  * `1` - Manhatten Metric * `2` - Euclidian Metric"" optional=""true"" value=""2"" min=""0"" />"	Param: 'p' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.scores	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.scores	n	Int > 0	"<param type=""integer"" argument=""n"" label=""Number of periods to be included into the LOF calculation"" help=""Defaults to `20`, which is a value found to be suitable in the literature.  * `n` determines the  locality  of an observation (its `n` nearest neighbors) and sets the upper limit of values of an outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n/2` may not be detected reliably. * The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outliers points. Higher values greatly increase numerical costs"" optional=""true"" value=""20"" min=""0"" />"	Param: 'n' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.scores	algorithm	Literal['ball_tree', 'kd_tree', 'brute', 'auto']	"<param type=""select"" argument=""algorithm"" label=""algorithm"" help=""Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation"" optional=""true"" value=""ball_tree"" />"	Param: 'algorithm' -> Annotation: 'Literal['ball_tree', 'kd_tree', 'brute', 'auto']' -> is_simple_type
saqc.funcs.scores	p	Int > 0	"<param type=""integer"" argument=""p"" label=""p"" help=""Degree of the metric ( Minkowski ), according to wich distance to neighbors is determined. Most important values are:  * `1` - Manhatten Metric * `2` - Euclidian Metric"" optional=""true"" value=""1"" min=""0"" />"	Param: 'p' -> Annotation: 'Int > 0' -> is_simple_type
saqc.funcs.scores	density	Literal['auto'] | (Float > 0)	"<conditional name=""density_cond"" label=""How to calculate the temporal distance/density for the variable-to-be-flagged"" />"	Param: 'density' -> Annotation: 'Literal['auto'] | (Float > 0)' -> is_union_type -> conditional
saqc.funcs.scores	fill_na	bool	"<param type=""boolean"" argument=""fill_na"" label=""If True, NaNs in the data are filled with a linear interpolation"" help=""If True, NaNs in the data are filled with a linear interpolation"" checked=""false"" truevalue=""fill_na"" falsevalue="""" />"	Param: 'fill_na' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.scores	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.scores	window	OffsetStr | None	"<param type=""text"" argument=""window"" label=""Size of the window"" help=""can be determined as: * Offset String, denoting the windows temporal extension * Integer, denoting the windows number of periods. * `None` (default), All data points share the same scoring window, which than equals the whole data"" optional=""true"" />"	Param: 'window' -> Annotation: 'OffsetStr | None' -> is_simple_type
saqc.funcs.scores	norm_func	Callable | str	"<conditional name=""norm_func_cond"" label=""norm_func"" />"	Param: 'norm_func' -> Annotation: 'Callable | str' -> is_union_type -> conditional
saqc.funcs.scores	model_func	Callable | str	"<conditional name=""model_func_cond"" label=""model_func"" />"	Param: 'model_func' -> Annotation: 'Callable | str' -> is_union_type -> conditional
saqc.funcs.scores	center	bool	"<param type=""boolean"" argument=""center"" label=""Weather or not to center the target value in the scoring window"" help=""If `False`, the target value is the last value in the window"" checked=""false"" truevalue=""center"" falsevalue="""" />"	Param: 'center' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.scores	min_periods	(Int >= 0) | None	"<param type=""integer"" argument=""min_periods"" label=""min_periods"" help=""Minimum number of valid meassurements in a scoring window, to consider the resulting score valid"" optional=""true"" min=""0"" />"	Param: 'min_periods' -> Annotation: '(Int >= 0) | None' -> is_simple_type
saqc.funcs.tools	field	str | list[str]	"<conditional name=""field_cond"" label=""Variable to process"" />"	Param: 'field' -> Annotation: 'str | list[str]' -> is_union_type -> conditional
saqc.funcs.tools	target	str | list[str]	"<conditional name=""target_cond"" label=""target"" />"	Param: 'target' -> Annotation: 'str | list[str]' -> is_union_type -> conditional
saqc.funcs.tools	overwrite	bool	"<param type=""boolean"" argument=""overwrite"" label=""overwrite"" help=""overwrite target, if already existant"" checked=""false"" truevalue=""overwrite"" falsevalue="""" />"	Param: 'overwrite' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.tools	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.tools	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.tools	max_gap	OffsetStr | None	"<param type=""text"" argument=""max_gap"" label=""max_gap"" help=""If ``None``, all data points will be connected, resulting in long linear lines, in case of large data gaps. ``NaN`` values will be removed before plotting. If an offset string is passed, only points that have a distance below ``max_gap`` are connected via the plotting line"" optional=""true"" />"	Param: 'max_gap' -> Annotation: 'OffsetStr | None' -> is_simple_type
saqc.funcs.tools	gui_mode	Literal['GUI', 'overlay']	"<param type=""select"" argument=""gui_mode"" label=""gui_mode"" help=""* `` GUI `` (default), spawns TK based pop-up GUI, enabling scrolling and binding for subplots * `` overlay ``, spawns matplotlib based pop-up GUI. May be less conflicting, but does not support scrolling or binding"" optional=""true"" value=""GUI"" />"	Param: 'gui_mode' -> Annotation: 'Literal['GUI', 'overlay']' -> is_simple_type
saqc.funcs.tools	dfilter	float	"<param type=""float"" argument=""dfilter"" label=""dfilter"" help="":py:class:`Any`, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme"" optional=""true"" value=""255.0"" />"	Param: 'dfilter' -> Annotation: 'float' -> is_simple_type
saqc.funcs.tools	field	str | list[str]	"<conditional name=""field_cond"" label=""Variable to process"" />"	Param: 'field' -> Annotation: 'str | list[str]' -> is_union_type -> conditional
saqc.funcs.tools	path	str | None	"<param type=""text"" argument=""path"" label=""path"" help=""If ``None`` is passed, interactive mode is entered; plots are shown immediatly and a user need to close them manually before execution continues. If a filepath is passed instead, store-mode is entered and the plot is stored unter the passed location"" optional=""true"" />"	Param: 'path' -> Annotation: 'str | None' -> is_simple_type
saqc.funcs.tools	max_gap	OffsetStr | None	"<param type=""text"" argument=""max_gap"" label=""max_gap"" help=""If ``None``, all data points will be connected, resulting in long linear lines, in case of large data gaps. ``NaN`` values will be removed before plotting. If an offset string is passed, only points that have a distance below ``max_gap`` are connected via the plotting line"" optional=""true"" />"	Param: 'max_gap' -> Annotation: 'OffsetStr | None' -> is_simple_type
saqc.funcs.tools	mode	Literal['subplots', 'oneplot'] | str	"<conditional name=""mode_cond"" label=""mode"" />"	Param: 'mode' -> Annotation: 'Literal['subplots', 'oneplot'] | str' -> is_union_type -> conditional
saqc.funcs.tools	history	Literal['valid', 'complete'] | list[str] | None	"<conditional name=""history_cond"" label=""Discriminate the plotted flags with respect to the tests they originate from"" />"	Param: 'history' -> Annotation: 'Literal['valid', 'complete'] | list[str] | None' -> is_union_type -> conditional
saqc.funcs.tools	xscope	slice | OffsetStr | str | None	"<conditional name=""xscope_cond"" label=""Determine a chunk of the data to be plotted"" />"	Param: 'xscope' -> Annotation: 'slice | OffsetStr | str | None' -> is_union_type -> conditional
saqc.funcs.tools	yscope	list[tuple[float, float]] | tuple[float, float] | dict | None	"<conditional name=""yscope_cond"" label=""yscope"" />"	Param: 'yscope' -> Annotation: 'list[tuple[float, float]] | tuple[float, float] | dict | None' -> is_union_type -> conditional
saqc.funcs.tools	dfilter	float	"<param type=""float"" argument=""dfilter"" label=""dfilter"" help="":py:class:`Any`, optional Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme"" optional=""true"" value=""inf"" />"	Param: 'dfilter' -> Annotation: 'float' -> is_simple_type
saqc.funcs.tools	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.tools	new_name	str	"<param type=""text"" argument=""new_name"" label=""String, field is to be replaced with"" help=""String, field is to be replaced with"" />"	Param: 'new_name' -> Annotation: 'str' -> is_simple_type
saqc.funcs.tools	field	str	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" />"	Param: 'field' -> Annotation: 'str' -> is_simple_type
saqc.funcs.tools	mode	Literal['periodic', 'selection_field']	"<param type=""select"" argument=""mode"" label=""The masking mode"" help=""-  periodic : parameters  period_start ,  end  are evaluated to generate a periodical mask -  mask_var : data[mask_var] is expected to be a boolean valued timeseries and is used as mask"" />"	Param: 'mode' -> Annotation: 'Literal['periodic', 'selection_field']' -> is_simple_type
saqc.funcs.tools	selection_field	str | None	"<param type=""text"" argument=""selection_field"" label=""selection_field"" help=""Only effective if mode ==  mask_var  Fieldname of the column, holding the data that is to be used as mask. (must be boolean series) Neither the series` length nor its labels have to match data[field]`s index and length. An inner join of the indices will be calculated and values get masked where the values of the inner join are ``True``"" optional=""true"" />"	Param: 'selection_field' -> Annotation: 'str | None' -> is_simple_type
saqc.funcs.tools	start	str | None	"<param type=""text"" argument=""start"" label=""start"" help=""Only effective if mode ==  seasonal  String denoting starting point of every period. Formally, it has to be a truncated instance of  mm-ddTHH:MM:SS . Has to be of same length as `end` parameter. See examples section below for some examples"" optional=""true"" />"	Param: 'start' -> Annotation: 'str | None' -> is_simple_type
saqc.funcs.tools	end	str | None	"<param type=""text"" argument=""end"" label=""end"" help=""Only effective if mode ==  periodic  String denoting starting point of every period. Formally, it has to be a truncated instance of  mm-ddTHH:MM:SS . Has to be of same length as `end` parameter. See examples section below for some examples"" optional=""true"" />"	Param: 'end' -> Annotation: 'str | None' -> is_simple_type
saqc.funcs.tools	closed	bool	"<param type=""boolean"" argument=""closed"" label=""Wheather or not to include the mask defining bounds to the mask"" help=""Wheather or not to include the mask defining bounds to the mask"" checked=""false"" truevalue=""closed"" falsevalue="""" />"	Param: 'closed' -> Annotation: 'bool' -> is_simple_type
saqc.funcs.transformation	field	SaQCFields	"<param type=""text"" argument=""field"" label=""Variable to process"" help=""Variable to process"" multiple=""true"" />"	Param: 'field' -> Annotation: 'SaQCFields' -> is_simple_type
saqc.funcs.transformation	func	Callable[[pd.Series | np.ndarray], pd.Series] | str	"<conditional name=""func_cond"" label=""Transformation function"" />"	Param: 'func' -> Annotation: 'Callable[[pd.Series | np.ndarray], pd.Series] | str' -> is_union_type -> conditional
saqc.funcs.transformation	freq	(Int > 0) | FreqStr | None	"<conditional name=""freq_cond"" label=""Size of the data window"" />"	Param: 'freq' -> Annotation: '(Int > 0) | FreqStr | None' -> is_union_type -> conditional
