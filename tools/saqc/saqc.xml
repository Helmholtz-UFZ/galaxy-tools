<tool name="SaQC" id="saqc" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="22.01">
  <description>quality control pipelines for environmental sensor data</description>
  <macros>
    <import>macros.xml</import>
  </macros>
  <expand macro="requirements"/>
  <version_command><![CDATA[python -c 'import saqc; print(saqc.__version__)']]></version_command>
  <command><![CDATA['$__tool_directory__'/json_to_saqc_config.py '$param_conf' > config.csv &&
  #for $i, $d in enumerate($data)
      ##maybe link to element_identifier
      ln -s '$d' '${i}.csv' &&
  #end for
  saqc --config config.csv
  #for $i, $d in enumerate($data)
      --data '${i}.csv'
  #end for
  --outfile output.csv]]></command>
  <configfiles>
    <inputs name="param_conf"/>
  </configfiles>
  <inputs>
    <param argument="--data" type="data" label="Input table(s)" format="csv" multiple="true"/>
    <repeat name="methods_repeat" title="Methods (add multiple QC steps)">
      <conditional name="module_cond" label="SaQC Module">
        <param name="module_select" type="select" optional="false" label="Select SaQC module">
          <option value="breaks">breaks: Detecting breaks in data</option>
          <option value="changepoints">changepoints: changepoints</option>
          <option value="constants">constants: constants</option>
          <option value="curvefit">curvefit: curvefit</option>
          <option value="drift">drift: drift</option>
          <option value="flagtools">flagtools: flagtools</option>
          <option value="generic">generic: generic</option>
          <option value="interpolation">interpolation: interpolation</option>
          <option value="noise">noise: noise</option>
          <option value="outliers">outliers: outliers</option>
          <option value="pattern">pattern: pattern</option>
          <option value="resampling">resampling: resampling</option>
          <option value="residuals">residuals: residuals</option>
          <option value="rolling">rolling: rolling</option>
          <option value="scores">scores: scores</option>
          <option value="tools">tools: tools</option>
          <option value="transformation">transformation: transformation</option>
        </param>
        <when value="breaks">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="flagIsolated">flagIsolated: Find and flag temporal isolated groups of data</option>
              <option value="flagJumps">flagJumps: Flag jumps and drops in data</option>
              <option value="flagMissing">flagMissing: Flag NaNs in data</option>
            </param>
            <when value="flagIsolated">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="gap_window" type="text" value="" optional="false" label="Minimum gap size required before and after a data group to consider it" help="Minimum gap size required before and after a data group to consider it&#10;isolated. See condition (2) and (3)"/>
              <param argument="group_window" type="text" value="" optional="false" label="Maximum size of a data chunk to consider it a candidate for an isolated group." help="Maximum size of a data chunk to consider it a candidate for an isolated group.&#10;Data chunks that are bigger than the :py:attr:`group_window` are ignored.&#10;This does not include the possible gaps surrounding it.&#10;See condition (1)."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagJumps">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="thresh" type="float" value="" optional="false" label="Threshold value by which the mean of data has to jump, to trigger flagging." help="Threshold value by which the mean of data has to jump, to trigger flagging."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the two moving windows." help="Size of the two moving windows. This determines the number of observations used for&#10;calculating the mean in every window. The window size should be big enough to yield enough&#10;samples for a reliable mean calculation, but it should also not be arbitrarily big, since&#10;it also limits the density of jumps that can be detected.&#10;More precisely: Jumps that are not distanced to each other by more than three fourth (3/4)&#10;of the selected :py:attr:`window` size, will not be detected reliably."/>
              <param argument="min_periods" type="integer" value="1" optional="true" label="The minimum number of observations in :py:attr:`window` required to calculate..." help="The minimum number of observations in :py:attr:`window` required to calculate a valid mean value."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
              <param argument="dfilter" type="float" value="-inf" optional="true" label="Any, optional" help="Any, optional&#10;Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme."/>
            </when>
            <when value="flagMissing">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
              <param argument="dfilter" type="float" value="-inf" optional="true" label="Any, optional" help="Any, optional&#10;Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="changepoints">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="assignChangePointCluster">assignChangePointCluster: Label data where it changes significantly</option>
              <option value="flagChangePoints">flagChangePoints: Flag values that represent a system state transition</option>
            </param>
            <when value="assignChangePointCluster">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="stat_func" type="text" value="" optional="false" label="A function that assigns a value to every twin window." help="A function that assigns a value to every twin window. Left window content will&#10;be passed to first variable,&#10;right window content will be passed to the second."/>
              <param argument="thresh_func" type="text" value="" optional="false" label="A function that determines the value level, exceeding wich qualifies a" help="A function that determines the value level, exceeding wich qualifies a&#10;timestamps func value as denoting a changepoint."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the rolling windows the calculation is performed in." help="Size of the rolling windows the calculation is performed in. If it is a single&#10;frequency offset, it applies for the backward- and the forward-facing window.&#10;&#10;If two offsets (as a tuple) is passed the first defines the size of the&#10;backward facing window, the second the size of the forward facing window.&#10;(String or two comma-separated strings, e.g., val1,val2)"/>
              <param argument="min_periods" type="text" value="" optional="false" label="Minimum number of observations in a window required to perform the changepoint" help="Minimum number of observations in a window required to perform the changepoint&#10;test. If it is a tuple of two int, the first refer to the backward-,&#10;the second to the forward-facing window.&#10;(Integer or two comma-separated integers, e.g., 1,2)"/>
              <param argument="reduce_window" type="text" optional="true" label="The sliding window search method is not an exact CP search method and usually" help="The sliding window search method is not an exact CP search method and usually&#10;there won't be detected a single changepoint, but a &quot;region&quot; of change around&#10;a changepoint. If `reduce_window` is given, for every window of size&#10;`reduce_window`, there will be selected the value with index `reduce_func(x,&#10;y)` and the others will be dropped. If `reduce_window` is None, the reduction&#10;window size equals the twin window size, the changepoints have been detected&#10;with."/>
              <param argument="reduce_func" type="text" value="&lt;function ChangepointsMixin.&lt;lambda&gt; at 0x7012d15ae200&gt;" optional="true" label="default argmax" help="default argmax&#10;A function that must return an index value upon input of two arrays x and y.&#10;First input parameter will hold the result from the stat_func evaluation for&#10;every reduction window. Second input parameter holds the result from the&#10;thresh_func evaluation. The default reduction function just selects the value&#10;that maximizes the stat_func."/>
              <param argument="--model_by_resids" type="boolean" optional="true" label="If True, the results of `stat_funcs` are written, otherwise the regime labels." help="If True, the results of `stat_funcs` are written, otherwise the regime labels." checked="false" truevalue="--model_by_resids" falsevalue=""/>
            </when>
            <when value="flagChangePoints">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="stat_func" type="text" value="" optional="false" label="A function that assigns a value to every twin window." help="A function that assigns a value to every twin window. The backward-facing&#10;window content will be passed as the first array, the forward-facing window&#10;content as the second."/>
              <param argument="thresh_func" type="text" value="" optional="false" label="A function that determines the value level, exceeding wich qualifies a" help="A function that determines the value level, exceeding wich qualifies a&#10;timestamps func value as denoting a change-point."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the moving windows." help="Size of the moving windows. This is the number of observations used for&#10;calculating the statistic.&#10;&#10;If it is a single frequency offset, it applies for the backward- and the&#10;forward-facing window.&#10;&#10;If two offsets (as a tuple) is passed the first defines the size of the&#10;backward facing window, the second the size of the forward facing window.&#10;(String or two comma-separated strings, e.g., val1,val2)"/>
              <param argument="min_periods" type="text" value="" optional="false" label="Minimum number of observations in a window required to perform the changepoint" help="Minimum number of observations in a window required to perform the changepoint&#10;test. If it is a tuple of two int, the first refer to the backward-,&#10;the second to the forward-facing window.&#10;(Integer or two comma-separated integers, e.g., 1,2)"/>
              <param argument="reduce_window" type="text" optional="true" label="The sliding window search method is not an exact CP search method and usually" help="The sliding window search method is not an exact CP search method and usually&#10;there wont be detected a single changepoint, but a &quot;region&quot; of change around&#10;a changepoint.&#10;&#10;If `reduce_window` is given, for every window of size `reduce_window`, there&#10;will be selected the value with index `reduce_func(x, y)` and the others will&#10;be dropped.&#10;&#10;If `reduce_window` is None, the reduction window size equals the twin window&#10;size, the changepoints have been detected with."/>
              <param argument="reduce_func" type="text" value="&lt;function ChangepointsMixin.&lt;lambda&gt; at 0x7012d15ae020&gt;" optional="true" label="default argmax" help="default argmax&#10;A function that must return an index value upon input of two arrays x and y.&#10;First input parameter will hold the result from the stat_func evaluation for&#10;every reduction window. Second input parameter holds the result from the&#10;`thresh_func` evaluation.&#10;The default reduction function just selects the value that maximizes the&#10;`stat_func`."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="constants">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="flagByVariance">flagByVariance: Flag low-variance data</option>
              <option value="flagConstants">flagConstants: Flag constant data values</option>
            </param>
            <when value="flagByVariance">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the moving window." help="Size of the moving window. This is the number of observations used&#10;for calculating the statistic. Each window will be a fixed size.&#10;If its an offset then this will be the time period of each window.&#10;Each window will be sized, based on the number of observations included&#10;in the time-period."/>
              <param argument="thresh" type="float" value="" optional="false" label="Maximum total variance allowed per window." help="Maximum total variance allowed per window."/>
              <param argument="maxna" type="integer" optional="true" label="Maximum number of NaNs allowed in window." help="Maximum number of NaNs allowed in window.&#10;If more NaNs are present, the window is not flagged."/>
              <param argument="maxna_group" type="integer" optional="true" label="Same as `maxna` but for consecutive NaNs." help="Same as `maxna` but for consecutive NaNs."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagConstants">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="thresh" type="float" value="" optional="false" label="Maximum total change allowed per window." help="Maximum total change allowed per window."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the moving window." help="Size of the moving window. This determines the number of observations used&#10;for calculating the absolute change per window.&#10;Each window will either contain a fixed number of periods (integer defined window),&#10;or will have a fixed temporal extension (offset defined window)."/>
              <param argument="min_periods" type="integer" value="2" optional="true" label="Minimum number of observations in window required to generate" help="Minimum number of observations in window required to generate&#10;a flag. This can be used to exclude underpopulated *offset* defined windows from&#10;flagging. (Integer defined windows will always contain exactly *window* samples).&#10;Must be an integer greater or equal `2`, because a&#10;single value would always be considered constant.&#10;Defaults to `2`."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="curvefit">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="fitLowpassFilter">fitLowpassFilter: Fits the data using the butterworth filter</option>
              <option value="fitPolynomial">fitPolynomial: Fits a polynomial model to the data</option>
            </param>
            <when value="fitLowpassFilter">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="cutoff" type="text" value="" optional="false" label="The cutoff-frequency, either an offset freq string, or expressed in multiples..." help="The cutoff-frequency, either an offset freq string, or expressed in multiples of the sampling rate."/>
              <param argument="nyq" type="float" value="0.5" optional="true" label="The niquist-frequency." help="The niquist-frequency. expressed in multiples if the sampling rate."/>
              <param argument="filter_order" type="integer" value="2" optional="true" label="filter_order" help=""/>
              <param argument="fill_method" type="select" value="linear" optional="true" label="Fill method to be applied on the data before filtering (butterfilter cant" help="Fill method to be applied on the data before filtering (butterfilter cant&#10;handle ''np.nan''). See documentation of pandas.Series.interpolate method for&#10;details on the methods associated with the different keywords.">
                <option value="linear">linear</option>
                <option value="nearest">nearest</option>
                <option value="zero">zero</option>
                <option value="slinear">slinear</option>
                <option value="quadratic">quadratic</option>
                <option value="cubic">cubic</option>
                <option value="spline">spline</option>
                <option value="barycentric">barycentric</option>
                <option value="polynomial">polynomial</option>
              </param>
            </when>
            <when value="fitPolynomial">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the window you want to use for fitting." help="Size of the window you want to use for fitting. If an integer is passed,&#10;the size refers to the number of periods for every fitting window. If an&#10;offset string is passed, the size refers to the total temporal extension. The&#10;window will be centered around the vaule-to-be-fitted. For regularly sampled&#10;data always a odd number of periods will be used for the fit (periods-1 if&#10;periods is even)."/>
              <param argument="order" type="integer" value="" optional="false" label="Degree of the polynomial used for fitting" help="Degree of the polynomial used for fitting"/>
              <param argument="min_periods" type="integer" value="0" optional="true" label="Minimum number of observations in a window required to perform the fit," help="Minimum number of observations in a window required to perform the fit,&#10;otherwise NaNs will be assigned.&#10;If ``None``, `min_periods` defaults to 1 for integer windows and to the&#10;size of the window for offset based windows.&#10;Passing 0, disables the feature and will result in over-fitting for too&#10;sparse windows."/>
            </when>
          </conditional>
        </when>
        <when value="drift">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="assignRegimeAnomaly">assignRegimeAnomaly: A function to detect values belonging to an anomalous regime regarding modelling</option>
              <option value="correctDrift">correctDrift: The function corrects drifting behavior</option>
              <option value="correctOffset">correctOffset: Parameters</option>
              <option value="correctRegimeAnomaly">correctRegimeAnomaly: Function fits the passed model to the different regimes in data[field] and tries to correct</option>
              <option value="flagDriftFromNorm">flagDriftFromNorm: Flags data that deviates from an avarage data course</option>
              <option value="flagDriftFromReference">flagDriftFromReference: Flags data that deviates from a reference course. Deviation is measured by a</option>
              <option value="flagRegimeAnomaly">flagRegimeAnomaly: Flags anomalous regimes regarding to modelling regimes of ``field``</option>
            </param>
            <when value="assignRegimeAnomaly">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="cluster_field" type="text" value="" optional="false" label="Column in data, holding the cluster labels for the samples in field." help="Column in data, holding the cluster labels for the samples in field.&#10;(has to be indexed equal to field)"/>
              <param argument="spread" type="float" value="" optional="false" label="A threshold denoting the value level, up to wich clusters a agglomerated." help="A threshold denoting the value level, up to wich clusters a agglomerated."/>
              <param argument="method" type="select" value="single" optional="true" label="The linkage method for hierarchical (agglomerative) clustering of the variables." help="The linkage method for hierarchical (agglomerative) clustering of the variables.">
                <option value="single">single</option>
                <option value="complete">complete</option>
                <option value="average">average</option>
                <option value="weighted">weighted</option>
                <option value="centroid">centroid</option>
                <option value="median">median</option>
                <option value="ward">ward</option>
              </param>
              <param argument="metric" type="text" value="&lt;function DriftMixin.&lt;lambda&gt; at 0x7012ce019760&gt;" optional="true" label="A metric function for calculating the dissimilarity between 2 regimes." help="A metric function for calculating the dissimilarity between 2 regimes.&#10;Defaults to the absolute difference in mean."/>
              <param argument="frac" type="float" value="0.5" optional="true" label="The minimum percentage of samples, the &quot;normal&quot; group has to comprise to" help="The minimum percentage of samples, the &quot;normal&quot; group has to comprise to&#10;actually be the normal group. Must be in the closed interval `[0,1]`,&#10;otherwise a ValueError is raised."/>
            </when>
            <when value="correctDrift">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="maintenance_field" type="text" value="" optional="false" label="Column holding the support-points information." help="Column holding the support-points information.&#10;The data is expected to have the following form:&#10;The index of the series represents the beginning of a maintenance&#10;event, wheras the values represent its endings."/>
              <conditional name="model_cond">
                <param name="model_select_type" type="select" value="linear" optional="false" label="A model function describing the drift behavior, that is to be corrected. Model Type">
                  <option value="linear">Linear Model</option>
                  <option value="exponential">Exponential Model</option>
                  <option value="custom">Custom Callable</option>
                </param>
                <when value="linear">
                  <param name="model" type="hidden" value="linear" label=""/>
                </when>
                <when value="exponential">
                  <param name="model" type="hidden" value="exponential" label=""/>
                </when>
                <when value="custom">
                  <param argument="model" type="text" value="" optional="false" label="A model function describing the drift behavior, that is to be corrected. (Custom Callable Name)" help="A model function describing the drift behavior, that is to be corrected.&#10;Either use built-in exponential or linear drift model by passing a string,&#10;or pass a custom callable. The model function must always contain the keyword&#10;parameters 'origin' and 'target'. The starting parameter must always be the&#10;parameter, by wich the data is passed to the model. After the data parameter,&#10;there can occure an arbitrary number of model calibration arguments in the&#10;signature. See the Notes section for an extensive description."/>
                </when>
              </conditional>
              <param argument="cal_range" type="integer" value="5" optional="true" label="Number of values to calculate the mean of, for obtaining the value level dire..." help="Number of values to calculate the mean of, for obtaining the value level directly&#10;after and directly before a maintenance event. Needed for shift calibration."/>
            </when>
            <when value="correctOffset">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="max_jump" type="float" value="" optional="false" label="when searching for changepoints in mean - this is the threshold a mean differ..." help="when searching for changepoints in mean - this is the threshold a mean difference in the&#10;sliding window search must exceed to trigger changepoint detection."/>
              <param argument="spread" type="float" value="" optional="false" label="threshold denoting the maximum, regimes are allowed to abolutely differ in th..." help="threshold denoting the maximum, regimes are allowed to abolutely differ in their means&#10;to form the &quot;normal group&quot; of values."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the adjacent windows that are used to search for the mean changepoints." help="Size of the adjacent windows that are used to search for the mean changepoints."/>
              <param argument="min_periods" type="integer" value="" optional="false" label="Minimum number of periods a search window has to contain, for the result of t..." help="Minimum number of periods a search window has to contain, for the result of the changepoint&#10;detection to be considered valid."/>
              <param argument="tolerance" type="text" optional="true" label="If an offset string is passed, a data chunk of length `offset` right from the" help="If an offset string is passed, a data chunk of length `offset` right from the&#10;start and right before the end of any regime is ignored when calculating a regimes mean for data correcture.&#10;This is to account for the unrelyability of data near the changepoints of regimes."/>
            </when>
            <when value="correctRegimeAnomaly">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="cluster_field" type="text" value="" optional="false" label="A string denoting the field in data, holding the cluster label for the data y..." help="A string denoting the field in data, holding the cluster label for the data you want&#10;to correct."/>
              <param argument="model" type="text" value="" optional="false" label="The model function to be fitted to the regimes." help="The model function to be fitted to the regimes.&#10;It must be a function of the form :math:`f(x, *p)`, where :math:`x` is the&#10;``numpy.array`` holding the independent variables and :math:`p` are the model&#10;parameters that are to be obtained by fitting. Depending on the `x_date` parameter,&#10;independent variable x will either be the timestamps of every regime transformed to&#10;seconds from epoch, or it will be just seconds, counting the regimes length.&#10;(Expects a function reference: (...).)"/>
              <param argument="tolerance" type="text" optional="true" label="If an offset string is passed, a data chunk of length `offset` right at the" help="If an offset string is passed, a data chunk of length `offset` right at the&#10;start and right at the end is ignored when fitting the model. This is to&#10;account for the unreliability of data near the changepoints of regimes.&#10;Defaults to None."/>
              <param argument="--epoch" type="boolean" optional="true" label="If True, use &quot;seconds from epoch&quot; as x input to the model func, instead of" help="If True, use &quot;seconds from epoch&quot; as x input to the model func, instead of&#10;&quot;seconds from regime start&quot;." checked="false" truevalue="--epoch" falsevalue=""/>
            </when>
            <when value="flagDriftFromNorm">
              <repeat name="field_repeat" title="Field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Name for field" help="str | list[str]&#10;Variable to process."/>
              </repeat>
              <param argument="window" type="text" value="" optional="false" label="Frequency, that split the data in chunks." help="Frequency, that split the data in chunks."/>
              <param argument="spread" type="float" value="" optional="false" label="Maximum spread allowed in the group of *normal* data." help="Maximum spread allowed in the group of *normal* data. See Notes section for more details."/>
              <param argument="frac" type="float" value="0.5" optional="true" label="Fraction defining the normal group." help="Fraction defining the normal group. Use a value from the interval [0,1].&#10;The higher the value, the more stable the algorithm will be. For values below&#10;0.5 the results are undefined."/>
              <param argument="metric" type="text" value="&lt;function cityblock at 0x7012ce018900&gt;" optional="true" label="default cityblock" help="default cityblock&#10;Distance function that takes two arrays as input and returns a scalar float.&#10;This value is interpreted as the distance of the two input arrays.&#10;Defaults to the `averaged manhattan metric` (see Notes)."/>
              <param argument="method" type="select" value="single" optional="true" label="Linkage method used for hierarchical (agglomerative) clustering of the data." help="Linkage method used for hierarchical (agglomerative) clustering of the data.&#10;`method` is directly passed to ``scipy.hierarchy.linkage``. See its documentation [1] for&#10;more details. For a general introduction on hierarchical clustering see [2].">
                <option value="single">single</option>
                <option value="complete">complete</option>
                <option value="average">average</option>
                <option value="weighted">weighted</option>
                <option value="centroid">centroid</option>
                <option value="median">median</option>
                <option value="ward">ward</option>
              </param>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagDriftFromReference">
              <repeat name="field_repeat" title="Field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Name for field" help="str | list[str]&#10;Variable to process."/>
              </repeat>
              <param argument="reference" type="text" value="" optional="false" label="Reference variable, the deviation is calculated from." help="Reference variable, the deviation is calculated from."/>
              <param argument="freq" type="text" value="" optional="false" label="Frequency, that split the data in chunks." help="Frequency, that split the data in chunks."/>
              <param argument="thresh" type="float" value="" optional="false" label="Maximum deviation from reference." help="Maximum deviation from reference."/>
              <param argument="metric" type="text" value="&lt;function cityblock at 0x7012ce018900&gt;" optional="true" label="default cityblock" help="default cityblock&#10;Distance function. Takes two arrays as input and returns a scalar float.&#10;This value is interpreted as the mutual distance of the two input arrays.&#10;Defaults to the `averaged manhattan metric` (see Notes)."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagRegimeAnomaly">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="cluster_field" type="text" value="" optional="false" label="Column in data, holding the cluster labels for the samples in field." help="Column in data, holding the cluster labels for the samples in field.&#10;(has to be indexed equal to field)"/>
              <param argument="spread" type="float" value="" optional="false" label="A threshold denoting the value level, up to wich clusters a agglomerated." help="A threshold denoting the value level, up to wich clusters a agglomerated."/>
              <param argument="method" type="select" value="single" optional="true" label="The linkage method for hierarchical (agglomerative) clustering of the variables." help="The linkage method for hierarchical (agglomerative) clustering of the variables.">
                <option value="single">single</option>
                <option value="complete">complete</option>
                <option value="average">average</option>
                <option value="weighted">weighted</option>
                <option value="centroid">centroid</option>
                <option value="median">median</option>
                <option value="ward">ward</option>
              </param>
              <param argument="metric" type="text" value="&lt;function DriftMixin.&lt;lambda&gt; at 0x7012ce019620&gt;" optional="true" label="A metric function for calculating the dissimilarity between 2 regimes." help="A metric function for calculating the dissimilarity between 2 regimes.&#10;Defaults to the absolute difference in mean."/>
              <param argument="frac" type="float" value="0.5" optional="true" label="The minimum percentage of samples, the &quot;normal&quot; group has to comprise to" help="The minimum percentage of samples, the &quot;normal&quot; group has to comprise to&#10;actually be the normal group. Must be in the closed interval `[0,1]`,&#10;otherwise a ValueError is raised."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="flagtools">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="andGroup">andGroup: Flag all values, if all the given ``field`` values are already flagged</option>
              <option value="clearFlags">clearFlags: Assign UNFLAGGED value to all periods in field</option>
              <option value="flagDummy">flagDummy: Function does nothing but returning data and flags</option>
              <option value="flagManual">flagManual: Include flags listed in external data</option>
              <option value="flagUnflagged">flagUnflagged: Function sets a flag at all unflagged positions</option>
              <option value="forceFlags">forceFlags: Set whole column to a flag value</option>
              <option value="orGroup">orGroup: Flag all values, if at least one of the given ``field`` values is already flagged</option>
              <option value="propagateFlags">propagateFlags: Flag values before or after flags set by the last test</option>
              <option value="transferFlags">transferFlags: Transfer Flags of one variable to another</option>
            </param>
            <when value="andGroup">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="group" type="text" optional="true" label="A collection of ``SaQC`` objects." help="A collection of ``SaQC`` objects. Flag checks are performed on all ``SaQC`` objects&#10;based on the variables specified in ``field``. Whenever all monitored variables&#10;are flagged, the associated timestamps will receive a flag."/>
              <param argument="target" type="text" optional="true" label="str | list[str], optional" help="str | list[str], optional&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="clearFlags">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
            </when>
            <when value="flagDummy">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
            </when>
            <when value="flagManual">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="mdata" type="text" value="" optional="false" label="Determines which values or intervals will be flagged." help="Determines which values or intervals will be flagged. Supported input types:&#10;&#10;* ``pd.Series``: Needs a datetime index and values of type:&#10;&#10;- datetime, for :py:attr:`method` values ``&quot;right-closed&quot;``, ``&quot;left-closed&quot;``, ``&quot;closed&quot;``&#10;- or any scalar, for :py:attr:`method` values ``&quot;plain&quot;``, ``&quot;ontime&quot;``&#10;&#10;* ``str``: Variable holding the manual flag information.&#10;* ``pd.DataFrame``, ``DictOfSeries``: Need to provide a ``pd.Series`` with column name&#10;:py:attr:`field`.&#10;* ``list``, ``np.ndarray``: Only supported with :py:attr:`method` value ``&quot;plain&quot;`` and&#10;:py:attr:`mformat` value ``&quot;mflag&quot;``"/>
              <param argument="method" type="select" value="left-open" optional="true" label="Defines how :py:attr:`mdata` is projected to data:" help="Defines how :py:attr:`mdata` is projected to data:&#10;&#10;* ``&quot;plain&quot;``: :py:attr:`mdata` must have the same length as :py:attr:`field`, flags&#10;are set, where the values in :py:attr:`mdata` equal :py:attr:`mflag`.&#10;* ``&quot;ontime&quot;``: Expects datetime indexed :py:attr:`mdata` (types ``pd.Series``,&#10;``pd.DataFrame``, ``DictOfSeries``). Flags are set, where the values in&#10;:py:attr:`mdata` equal :py:attr:`mflag` and the indices of :py:attr:`field` and&#10;:py:attr:`mdata` match.&#10;* ``&quot;right-open&quot;``: Expects datetime indexed :py:attr:`mdata`, which will be interpreted&#10;as a number of time intervals ``t_1, t_2``. Flags are set to all timestamps ``t`` of&#10;:py:attr:`field` with ``t_1 &lt;= t &lt; t_2``.&#10;* ``&quot;left-open&quot;``: like ``&quot;right-open&quot;``, but the interval covers all ``t`` with&#10;``t_1 &lt; t &lt;= t_2``.&#10;* ``&quot;closed&quot;``: like ``&quot;right-open&quot;``, but the interval now covers all ``t`` with&#10;``t_1 &lt;= t &lt;= t_2``.">
                <option value="left-open">left-open</option>
                <option value="right-open">right-open</option>
                <option value="closed">closed</option>
                <option value="plain">plain</option>
                <option value="ontime">ontime</option>
              </param>
              <param argument="mformat" type="select" value="start-end" optional="true" label="Controls the interval definition in :py:attr:`mdata` (see examples):" help="Controls the interval definition in :py:attr:`mdata` (see examples):&#10;&#10;* ``&quot;start-end&quot;``: expects datetime indexed :py:attr:`mdata` (types ``pd.Series``,&#10;``pd.DataFrame``, ``DictOfSeries``) with values of type datetime. Each&#10;index-value pair is interpreted as an interval to flag, the index defines the&#10;left bound, the respective value the right bound.&#10;* ``&quot;mflag&quot;``:&#10;&#10;- :py:attr:`mdata` of type ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``:&#10;Two successive index values ``i_1, i_2`` will be interpreted as an interval&#10;``t_1, t_2`` to flag, if the value of ``t_1`` equals :py:attr:`mflag`&#10;- :py:attr:`mdata` of type ``list``, ``np.ndarray``: Flags all :py:attr:`field`&#10;where :py:attr:`mdata` euqals :py:attr:`mflag`.">
                <option value="start-end">start-end</option>
                <option value="mflag">mflag</option>
              </param>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagUnflagged">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="forceFlags">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="flag" help=""/>
            </when>
            <when value="orGroup">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="group" type="text" optional="true" label="A collection of ``SaQC`` objects." help="A collection of ``SaQC`` objects. Flag checks are performed on all ``SaQC`` objects&#10;based on the variables specified in :py:attr:`field`. Whenever any of monitored variables&#10;is flagged, the associated timestamps will receive a flag."/>
              <param argument="target" type="text" optional="true" label="str | list[str], optional" help="str | list[str], optional&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="propagateFlags">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the repetition window." help="Size of the repetition window. An integer defines the exact&#10;number of repetitions, strings are interpreted as time offsets&#10;to fill with."/>
              <param argument="method" type="select" value="ffill" optional="true" label="Direction of repetetion." help="Direction of repetetion. With &quot;ffill&quot; the subsequent values&#10;receive the flag to repeat, with &quot;bfill&quot; the previous values.">
                <option value="ffill">ffill</option>
                <option value="bfill">bfill</option>
              </param>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
              <param argument="dfilter" type="float" value="-inf" optional="true" label="Any, optional" help="Any, optional&#10;Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme."/>
            </when>
            <when value="transferFlags">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="target" type="text" optional="true" label="str | list[str], optional" help="str | list[str], optional&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="--squeeze" type="boolean" optional="true" label="Squeeze the history into a single column if ``True``, function specific flag ..." help="Squeeze the history into a single column if ``True``, function specific flag information is lost." checked="false" truevalue="--squeeze" falsevalue=""/>
              <param argument="--overwrite" type="boolean" optional="true" label="Overwrite existing flags if ``True``." help="Overwrite existing flags if ``True``." checked="false" truevalue="--overwrite" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="generic">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="flagGeneric">flagGeneric: Flag data based on a given function</option>
              <option value="processGeneric">processGeneric: Generate/process data with user defined functions</option>
            </param>
            <when value="flagGeneric">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="func" type="text" value="" optional="false" label="Function to call." help="Function to call. The function needs to accept the same number of arguments&#10;(of type pandas.Series) as variables given in ``field`` and return an&#10;iterable of array-like objects of data type ``bool`` with the same length as&#10;``target``.&#10;(Expects a function reference: (...).)"/>
              <param argument="target" type="text" optional="true" label="str | list[str], optional" help="str | list[str], optional&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="processGeneric">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="func" type="text" value="" optional="false" label="Function to call on the variables given in ``field``." help="Function to call on the variables given in ``field``. The return value will be written&#10;to ``target`` or ``field`` if the former is not given. This implies, that the function&#10;needs to accept the same number of arguments (of type pandas.Series) as variables given&#10;in ``field`` and should return an iterable of array-like objects with the same number&#10;of elements as given in ``target`` (or ``field`` if ``target`` is not specified).&#10;(Expects a function reference: (...).)"/>
              <param argument="target" type="text" optional="true" label="str | list[str], optional" help="str | list[str], optional&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="dfilter" type="float" value="-inf" optional="true" label="Any, optional" help="Any, optional&#10;Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="interpolation">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="align">align: Convert time series to specified frequency. Values affected by</option>
              <option value="interpolateByRolling">interpolateByRolling: Replace NaN by the aggregation result of the surrounding window</option>
            </param>
            <when value="align">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="freq" type="text" value="" optional="false" label="Target frequency." help="Target frequency."/>
              <param argument="method" type="text" value="time" optional="true" label="Interpolation technique to use." help="Interpolation technique to use. One of:&#10;&#10;* ``'nshift'``: Shift grid points to the nearest time stamp&#10;in the range = +/- 0.5 * ``freq``.&#10;* ``'bshift'``: Shift grid points to the first succeeding&#10;time stamp (if any).&#10;* ``'fshift'``: Shift grid points to the last preceeding time&#10;stamp (if any).&#10;* ``'linear'``: Ignore the index and treat the values as equally&#10;spaced.&#10;* ``'time'``, ``'index'``, ``'values'``: Use the actual numerical&#10;values of the index.&#10;* ``'pad'``: Fill in NaNs using existing values.&#10;* ``'spline'``, ``'polynomial'``:&#10;Passed to ``scipy.interpolate.interp1d``. These methods&#10;use the numerical values of the index.  An ``order`` must be&#10;specified, e.g. ``qc.interpolate(method='polynomial', order=5)``.&#10;* ``'nearest'``, ``'zero'``, ``'slinear'``, ``'quadratic'``, ``'cubic'``, ``'barycentric'``:&#10;Passed to ``scipy.interpolate.interp1d``. These methods use&#10;the numerical values of the index.&#10;* ``'krogh'``, ``'spline'``, ``'pchip'``, ``'akima'``, ``'cubicspline'``:&#10;Wrappers around the SciPy interpolation methods of similar&#10;names.&#10;* ``'from_derivatives'``: Refers to ``scipy.interpolate.BPoly.from_derivatives``."/>
              <param argument="order" type="integer" value="2" optional="true" label="Order of the interpolation method, ignored if not supported" help="Order of the interpolation method, ignored if not supported&#10;by the chosen ``method``."/>
              <param argument="--overwrite" type="boolean" optional="true" label="If set to `True`, existing flags will be cleared." help="If set to `True`, existing flags will be cleared." checked="false" truevalue="--overwrite" falsevalue=""/>
            </when>
            <when value="interpolateByRolling">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="The size of the window, the aggregation is computed from." help="The size of the window, the aggregation is computed from.&#10;An integer define the number of periods to be used, a string&#10;is interpreted as an offset. ( see `pandas.rolling` for more&#10;information). Integer windows may result in screwed aggregations&#10;if called on none-harmonized or irregular data."/>
              <param argument="func" type="text" value="median" optional="true" label="default median" help="default median&#10;The function used for aggregation."/>
              <param argument="--center" type="boolean" optional="true" label="Center the window around the value." help="Center the window around the value. Can only be used with&#10;integer windows, otherwise it is silently ignored." checked="true" truevalue="--center" falsevalue=""/>
              <param argument="min_periods" type="integer" value="0" optional="true" label="Minimum number of valid (not np.nan) values that have to be" help="Minimum number of valid (not np.nan) values that have to be&#10;available in a window for its aggregation to be&#10;computed."/>
              <param argument="flag" type="float" value="-inf" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="noise">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="flagByScatterLowpass">flagByScatterLowpass: Flag data chunks of length ``window`` dependent on the data deviation</option>
              <option value="flagByStatLowPass">flagByStatLowPass: Flag data chunks of length ``window`` dependent on the data deviation</option>
            </param>
            <when value="flagByScatterLowpass">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="Window (i.e. chunk) size." help="Window (i.e. chunk) size."/>
              <param argument="thresh" type="float" value="" optional="false" label="Threshold." help="Threshold. A given chunk is flagged, if the return value of ``func`` excceeds ``thresh``."/>
              <param argument="func" type="text" value="std" optional="true" label="Either a string, determining the aggregation function applied on every chunk:" help="Either a string, determining the aggregation function applied on every chunk:&#10;&#10;* 'std': standard deviation&#10;* 'var': variance&#10;* 'mad': median absolute deviation&#10;&#10;Or a Callable, mapping 1 dimensional array likes onto scalars."/>
              <param argument="sub_window" type="text" optional="true" label="Window size of sub chunks, that are additionally tested for exceeding ``sub_t..." help="Window size of sub chunks, that are additionally tested for exceeding ``sub_thresh``&#10;with respect to ``func``.&#10;(Pandas timedelta string or offset, e.g., '1D', '2H30M')"/>
              <param argument="sub_thresh" type="float" optional="true" label="Threshold." help="Threshold. A given sub chunk is flagged, if the return value of ``func` excceeds ``sub_thresh``."/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of values needed in a chunk to perfom the test." help="Minimum number of values needed in a chunk to perfom the test.&#10;Ignored if ``window`` is an integer."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagByStatLowPass">
              <param argument="field" type="text" value="" optional="false" label="field" help=""/>
              <param argument="window" type="text" value="" optional="false" label="window" help=""/>
              <param argument="thresh" type="float" value="" optional="false" label="thresh" help=""/>
              <param argument="func" type="text" value="std" optional="true" label="Either a String value, determining the aggregation function applied on every ..." help="Either a String value, determining the aggregation function applied on every chunk.&#10;&#10;* 'std': standard deviation&#10;* 'var': variance&#10;* 'mad': median absolute deviation&#10;&#10;Or a Callable function mapping 1 dimensional arraylikes onto scalars.&#10;&#10;window :&#10;Window (i.e. chunk) size.&#10;&#10;thresh :&#10;Threshold. A given chunk is flagged, if the return value of ``func`` excceeds ``thresh``.&#10;&#10;sub_window :&#10;Window size of sub chunks, that are additionally tested for exceeding ``sub_thresh``&#10;with respect to ``func``.&#10;&#10;sub_thresh :&#10;Threshold. A given sub chunk is flagged, if the return value of ``func` excceeds ``sub_thresh``.&#10;&#10;min_periods :&#10;Minimum number of values needed in a chunk to perfom the test.&#10;Ignored if ``window`` is an integer."/>
              <param argument="sub_window" type="text" optional="true" label="sub_window" help="&#10;(Pandas timedelta string or offset, e.g., '1D', '2H30M')"/>
              <param argument="sub_thresh" type="float" optional="true" label="sub_thresh" help=""/>
              <param argument="min_periods" type="integer" optional="true" label="min_periods" help=""/>
              <param argument="flag" type="float" value="255.0" optional="true" label="flag" help=""/>
            </when>
          </conditional>
        </when>
        <when value="outliers">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="flagByGrubbs">flagByGrubbs: Flag outliers using the Grubbs algorithm</option>
              <option value="flagByStray">flagByStray: Flag outliers in 1-dimensional (score) data using the STRAY Algorithm</option>
              <option value="flagLOF">flagLOF: Flag values where the Local Outlier Factor (LOF) exceeds cutoff</option>
              <option value="flagMAD">flagMAD: Flag outiers using the modified Z-score outlier detection method</option>
              <option value="flagMVScores">flagMVScores: The algorithm implements a 3-step outlier detection procedure for</option>
              <option value="flagOffset">flagOffset: A basic outlier test that works on regularly and irregularly sampled data</option>
              <option value="flagRaise">flagRaise: The function flags raises and drops in value courses, that exceed a certain threshold within a certain timespan</option>
              <option value="flagRange">flagRange: Function flags values exceeding the closed</option>
              <option value="flagUniLOF">flagUniLOF: Flag "univariate" Local Outlier Factor (LOF) exceeding cutoff</option>
              <option value="flagZScore">flagZScore: Flag data where its (rolling) Zscore exceeds a threshold</option>
            </param>
            <when value="flagByGrubbs">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="Size of the testing window." help="Size of the testing window.&#10;If an integer, the fixed number of observations used for each window.&#10;If an offset string the time period of each window."/>
              <param argument="alpha" type="float" value="0.05" optional="true" label="Level of significance, the grubbs test is to be performed at." help="Level of significance, the grubbs test is to be performed at. Must be between 0 and 1."/>
              <param argument="min_periods" type="integer" value="8" optional="true" label="Minimum number of values needed in a :py:attr:`window` in order to perform th..." help="Minimum number of values needed in a :py:attr:`window` in order to perform the grubs test.&#10;Ignored if :py:attr:`window` is an integer."/>
              <param argument="--pedantic" type="boolean" optional="true" label="If ``True``, every value gets checked twice." help="If ``True``, every value gets checked twice. First in the initial rolling :py:attr:`window`&#10;and second in a rolling window that is lagging by :py:attr:`window` / 2. Recommended to avoid&#10;false positives at the window edges. Ignored if :py:attr:`window` is an offset string." checked="false" truevalue="--pedantic" falsevalue=""/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagByStray">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <conditional name="window_cond">
                <param name="window_select_type" type="select" value="none" optional="false" label="Determines the segmentation of the data into partitions, the Input Mode">
                  <option value="number">Number</option>
                  <option value="timedelta">Timedelta</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Determines the segmentation of the data into partitions, the (as number)" help="Determines the segmentation of the data into partitions, the&#10;kNN algorithm is applied onto individually.&#10;&#10;* ``None``: Apply Scoring on whole data set at once&#10;* ``int``: Apply scoring on successive data chunks of periods&#10;with the given length. Must be greater than 0.&#10;* offset String : Apply scoring on successive partitions of&#10;temporal extension matching the passed offset string"/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Determines the segmentation of the data into partitions, the (as timedelta string)" help="Determines the segmentation of the data into partitions, the&#10;kNN algorithm is applied onto individually.&#10;&#10;* ``None``: Apply Scoring on whole data set at once&#10;* ``int``: Apply scoring on successive data chunks of periods&#10;with the given length. Must be greater than 0.&#10;* offset String : Apply scoring on successive partitions of&#10;temporal extension matching the passed offset string"/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="11" optional="true" label="Minimum number of periods per partition that have to be present" help="Minimum number of periods per partition that have to be present&#10;for a valid outlier detection to be made in this partition"/>
              <param argument="iter_start" type="float" value="0.5" optional="true" label="Float in ``[0, 1]`` that determines which percentage of data" help="Float in ``[0, 1]`` that determines which percentage of data&#10;is considered &quot;normal&quot;. ``0.5`` results in the stray algorithm&#10;to search only the upper 50% of the scores for the cut off&#10;point. (See reference section for more information)"/>
              <param argument="alpha" type="float" value="0.05" optional="true" label="Level of significance by which it is tested, if a score might" help="Level of significance by which it is tested, if a score might&#10;be drawn from another distribution than the majority of the data."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagLOF">
              <repeat name="field_repeat" title="Field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Name for field" help="str | list[str]&#10;Variable to process."/>
              </repeat>
              <param argument="n" type="integer" value="20" optional="true" label="Number of neighbors to be included into the LOF calculation." help="Number of neighbors to be included into the LOF calculation.&#10;Defaults to ``20``, which is a&#10;value found to be suitable in the literature.&#10;&#10;* :py:attr:`n` determines the &quot;locality&quot; of an observation&#10;(its :py:attr:`n` nearest neighbors) and sets the upper&#10;limit to the number of values in outlier clusters (i.e.&#10;consecutive outliers). Outlier clusters of size greater&#10;than :py:attr:`n`/2 may not be detected reliably.&#10;* The larger :py:attr:`n`, the lesser the algorithm's sensitivity&#10;to local outliers and small or singleton outliers points.&#10;Higher values greatly increase numerical costs."/>
              <conditional name="thresh_cond">
                <param name="thresh_select_type" type="select" value="float" optional="false" label="The threshold for flagging the calculated LOF. Mode">
                  <option value="auto">Automatic ('auto')</option>
                  <option value="float">Specific Value (float)</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="auto">
                  <param name="thresh" type="hidden" value="auto" label=""/>
                </when>
                <when value="float">
                  <param argument="thresh" type="float" value="1.5" optional="false" label="The threshold for flagging the calculated LOF. (float value)" help="The threshold for flagging the calculated LOF. A LOF of around&#10;``1`` is considered normal and most likely corresponds to&#10;inlier points.&#10;&#10;* The &quot;automatic&quot; threshing introduced with the publication&#10;of the algorithm defaults to ``1.5``.&#10;* In this implementation, :py:attr:`thresh` defaults (``'auto'``)&#10;to flagging the scores with a modified 3-sigma rule."/>
                </when>
                <when value="none">
                  <param name="thresh" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="algorithm" type="select" value="ball_tree" optional="true" label="Algorithm used for calculating the :py:attr:`n`-nearest neighbors." help="Algorithm used for calculating the :py:attr:`n`-nearest neighbors.">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="1" optional="true" label="Degree of the metric (&quot;Minkowski&quot;), according to which the" help="Degree of the metric (&quot;Minkowski&quot;), according to which the&#10;distance to neighbors is determined. Most important values are:&#10;&#10;* ``1`` - Manhattan Metric&#10;* ``2`` - Euclidian Metric"/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagMAD">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <conditional name="window_cond">
                <param name="window_select_type" type="select" value="none" optional="false" label="Size of the window. Input Mode">
                  <option value="number">Number</option>
                  <option value="timedelta">Timedelta</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Size of the window. (as number)" help="Size of the window. Either given as an Offset String, denoting the window's temporal extension or&#10;as an integer, denoting the window's number of periods. ``NaN`` also count as periods.&#10;If ``None``, all data points share the same scoring window, which than equals the whole data."/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Size of the window. (as timedelta string)" help="Size of the window. Either given as an Offset String, denoting the window's temporal extension or&#10;as an integer, denoting the window's number of periods. ``NaN`` also count as periods.&#10;If ``None``, all data points share the same scoring window, which than equals the whole data."/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="z" type="float" value="3.5" optional="true" label="The value the Z-score is tested against." help="The value the Z-score is tested against. Defaulting to ``3.5`` (Recommendation of [1])"/>
              <param argument="min_residuals" type="integer" optional="true" label="min_residuals" help=""/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of valid meassurements in a scoring window, to consider the re..." help="Minimum number of valid meassurements in a scoring window, to consider the resulting score valid."/>
              <param argument="--center" type="boolean" optional="true" label="Weather or not to center the target value in the scoring window." help="Weather or not to center the target value in the scoring window. If ``False``, the&#10;target value is the last value in the window." checked="false" truevalue="--center" falsevalue=""/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagMVScores">
              <repeat name="field_repeat" title="Field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Name for field" help="List[str]&#10;List of variables names to process."/>
              </repeat>
              <param argument="trafo" type="text" value="&lt;function OutliersMixin.&lt;lambda&gt; at 0x7012ce049b20&gt;" optional="true" label="Transformation to be applied onto every column before scoring." help="Transformation to be applied onto every column before scoring. For more&#10;fine-grained control, the data could also be transformed before&#10;:py:meth:`~saqc.SaQC.flagMVScores` is called."/>
              <param argument="alpha" type="float" value="0.05" optional="true" label="Level of significance by which it is tested, if an observations score might" help="Level of significance by which it is tested, if an observations score might&#10;be drawn from another distribution than the majority of the data."/>
              <param argument="n" type="integer" value="10" optional="true" label="Number of neighbors included in the scoring process for every datapoint." help="Number of neighbors included in the scoring process for every datapoint."/>
              <param argument="func" type="text" value="sum" optional="true" label="Function that aggregates a value's k-smallest distances, returning a" help="Function that aggregates a value's k-smallest distances, returning a&#10;scalar score."/>
              <param argument="iter_start" type="float" value="0.5" optional="true" label="Value in ``[0,1]`` that determines which percentage of data is considered" help="Value in ``[0,1]`` that determines which percentage of data is considered&#10;&quot;normal&quot;. 0.5 results in the threshing algorithm to search only the upper&#10;50% of the scores for the cut-off point. (See reference section for more&#10;information)"/>
              <conditional name="window_cond">
                <param name="window_select_type" type="select" value="none" optional="false" label="Only effective if :py:attr:`threshing` is set to ``'stray'``. Input Mode">
                  <option value="number">Number</option>
                  <option value="timedelta">Timedelta</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Only effective if :py:attr:`threshing` is set to ``'stray'``. (as number)" help="Only effective if :py:attr:`threshing` is set to ``'stray'``. Determines&#10;the size of the data partitions, the data is decomposed into. Each&#10;partition is checked seperately for outliers. Either given as an Offset&#10;String, denoting the windows temporal extension or as an integer,&#10;denoting the windows number of periods. ``NaN`` also count as periods. If&#10;``None``, all data points share the same scoring window, which than&#10;equals the whole data."/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Only effective if :py:attr:`threshing` is set to ``'stray'``. (as timedelta string)" help="Only effective if :py:attr:`threshing` is set to ``'stray'``. Determines&#10;the size of the data partitions, the data is decomposed into. Each&#10;partition is checked seperately for outliers. Either given as an Offset&#10;String, denoting the windows temporal extension or as an integer,&#10;denoting the windows number of periods. ``NaN`` also count as periods. If&#10;``None``, all data points share the same scoring window, which than&#10;equals the whole data."/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="11" optional="true" label="Only effective if :py:attr:`threshing` is set to ``'stray'`` and" help="Only effective if :py:attr:`threshing` is set to ``'stray'`` and&#10;:py:attr:`partition` is an integer. Minimum number of periods per&#10;:py:attr:`partition` that have to be present for a valid outlier&#10;detection to be made in this partition."/>
              <param argument="stray_range" type="text" optional="true" label="If not ``None``, it is tried to reduce the stray result onto single" help="If not ``None``, it is tried to reduce the stray result onto single&#10;outlier components of the input :py:attr:`field`. The offset string&#10;denotes the range of the temporal surrounding to include into the MAD&#10;testing while trying to reduce flags."/>
              <param argument="--drop_flagged" type="boolean" optional="true" label="Only effective when :py:attr:`stray_range` is not ``None``." help="Only effective when :py:attr:`stray_range` is not ``None``. Whether or&#10;not to drop flagged values from the temporal surroundings." checked="false" truevalue="--drop_flagged" falsevalue=""/>
              <param argument="thresh" type="float" value="3.5" optional="true" label="Only effective when :py:attr:`stray_range` is not ``None``." help="Only effective when :py:attr:`stray_range` is not ``None``. The&#10;'critical' value, controlling wheather the MAD score is considered&#10;referring to an outlier or not. Higher values result in less rigid&#10;flagging. The default value is widely considered apropriate in the&#10;literature."/>
              <param argument="min_periods_r" type="integer" value="1" optional="true" label="Only effective when :py:attr:`stray_range` is not ``None``." help="Only effective when :py:attr:`stray_range` is not ``None``. Minimum&#10;number of measurements necessary in an interval to actually perform the&#10;reduction step."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagOffset">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="tolerance" type="float" value="" optional="false" label="Maximum difference allowed between the value, directly preceding and the valu..." help="Maximum difference allowed between the value, directly preceding and the value directly&#10;succeeding an offset to trigger flagging of the offsetting values. See condition (4)."/>
              <param argument="window" type="text" value="" optional="false" label="Maximum length allowed for offset value courses, to trigger flagging of the o..." help="Maximum length allowed for offset value courses, to trigger flagging of the offsetting values.&#10;See condition (5). Integer defined window length are only allowed for regularly sampled&#10;timeseries."/>
              <param argument="thresh" type="float" optional="true" label="Minimum difference between a value and its successors, to consider the succes..." help="Minimum difference between a value and its successors, to consider the successors an anomalous&#10;offset group. See condition (1). If ``None``, condition (1) is not tested."/>
              <param argument="thresh_relative" type="float" optional="true" label="Minimum relative change between a value and its successors, to consider the s..." help="Minimum relative change between a value and its successors, to consider the successors an anomalous&#10;offset group. See condition (2). If ``None``, condition (2) is not tested."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagRaise">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="thresh" type="float" value="" optional="false" label="The threshold, for the total rise (:py:attr:`thresh` ``&gt; 0``)," help="The threshold, for the total rise (:py:attr:`thresh` ``&gt; 0``),&#10;or total drop (:py:attr:`thresh` ``&lt; 0``), value courses must&#10;not exceed within a timespan of length :py:attr:`raise_window`."/>
              <param argument="raise_window" type="text" value="" optional="false" label="An offset string, determining the timespan, the rise/drop" help="An offset string, determining the timespan, the rise/drop&#10;thresholding refers to. Window is inclusively defined."/>
              <param argument="freq" type="text" value="" optional="false" label="An offset string, determining the frequency, the timeseries" help="An offset string, determining the frequency, the timeseries&#10;to flag is supposed to be sampled at. The window is inclusively&#10;defined."/>
              <param argument="average_window" type="text" optional="true" label="See condition (2) of the description given in the Notes." help="See condition (2) of the description given in the Notes. Window&#10;is inclusively defined, defaults to 1.5 times the size of&#10;:py:attr:`raise_window`."/>
              <param argument="raise_factor" type="float" value="2.0" optional="true" label="See condition (2)." help="See condition (2)."/>
              <param argument="slope" type="float" optional="true" label="See condition (3)." help="See condition (3)."/>
              <param argument="weight" type="float" value="0.8" optional="true" label="See condition (3)." help="See condition (3)."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagRange">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="min" type="float" value="-inf" optional="true" label="Lower bound for valid data." help="Lower bound for valid data."/>
              <param argument="max" type="float" value="inf" optional="true" label="Upper bound for valid data." help="Upper bound for valid data."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagUniLOF">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="n" type="integer" value="20" optional="true" label="Number of periods to be included into the LOF calculation." help="Number of periods to be included into the LOF calculation.&#10;Defaults to `20`, which is a value found to be suitable in&#10;the literature.&#10;&#10;* :py:attr:`n` determines the &quot;locality&quot; of an observation&#10;(its :py:attr:`n` nearest neighbors) and sets the upper&#10;limit to the number of values in an outlier clusters (i.e.&#10;consecutive outliers). Outlier clusters of size greater&#10;than :py:attr:`n`/2 may not be detected reliably.&#10;* The larger :py:attr:`n`, the lesser the algorithm's sensitivity&#10;to local outliers and small or singleton outlier points.&#10;Higher values greatly increase numerical costs."/>
              <conditional name="thresh_cond">
                <param name="thresh_select_type" type="select" value="float" optional="false" label="The threshold for flagging the calculated LOF. Mode">
                  <option value="auto">Automatic ('auto')</option>
                  <option value="float">Specific Value (float)</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="auto">
                  <param name="thresh" type="hidden" value="auto" label=""/>
                </when>
                <when value="float">
                  <param argument="thresh" type="float" value="1.5" optional="false" label="The threshold for flagging the calculated LOF. (float value)" help="The threshold for flagging the calculated LOF. A LOF of around&#10;``1`` is considered normal and most likely corresponds to&#10;inlier points. This parameter is considered the main calibration&#10;parameter of the algorithm.&#10;&#10;* The threshing defaults to ``1.5``, wich is the default value&#10;found to be suitable in the literature.&#10;* ``'auto'`` enables flagging the scores with a modified 3-sigma&#10;rule, resulting in a thresh around ``4``, which usually&#10;greatly mitigates overflagging compared to the literature&#10;recommendation, but often is too high.&#10;* sensitive range for the parameter may be ``[1,15]``, assuming&#10;default settings for the other parameters."/>
                </when>
                <when value="none">
                  <param name="thresh" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="algorithm" type="select" value="ball_tree" optional="true" label="Algorithm used for calculating the :py:attr:`n`-nearest neighbors" help="Algorithm used for calculating the :py:attr:`n`-nearest neighbors&#10;needed for LOF calculation.">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="1" optional="true" label="Degree of the metric (&quot;Minkowski&quot;), according to which distance" help="Degree of the metric (&quot;Minkowski&quot;), according to which distance&#10;to neighbors is determined. Most important values are:&#10;&#10;* ``1`` - Manhatten Metric&#10;* ``2`` - Euclidian Metric"/>
              <conditional name="density_cond">
                <param name="density_select_type" type="select" value="auto" optional="false" label="How to calculate the temporal distance/density for the variable Mode">
                  <option value="auto">Automatic ('auto')</option>
                  <option value="float">Specific Value (float)</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="auto">
                  <param name="density" type="hidden" value="auto" label=""/>
                </when>
                <when value="float">
                  <param argument="density" type="float" value="" optional="false" label="How to calculate the temporal distance/density for the variable (float value)" help="How to calculate the temporal distance/density for the variable&#10;to flag.&#10;&#10;* ``'auto'`` - introduces linear density with an increment&#10;equal to the median of the absolute diff of the variable to flag.&#10;* ``float`` - introduces linear density with an increment&#10;equal to :py:attr:`density`"/>
                </when>
                <when value="none">
                  <param name="density" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="--fill_na" type="boolean" optional="true" label="If True, NaNs in the data are filled with a linear interpolation." help="If True, NaNs in the data are filled with a linear interpolation." checked="true" truevalue="--fill_na" falsevalue=""/>
              <param argument="--slope_correct" type="boolean" optional="true" label="if True, a correction is applied, that removes outlier cluster that actually" help="if True, a correction is applied, that removes outlier cluster that actually&#10;just seem to be steep slopes" checked="true" truevalue="--slope_correct" falsevalue=""/>
              <param argument="min_offset" type="float" optional="true" label="If set, only those outlier cluster will be flagged, that are preceeded and su..." help="If set, only those outlier cluster will be flagged, that are preceeded and succeeeded&#10;by sufficiently large value &quot;jumps&quot;. Defaults to estimating the sufficient value jumps from&#10;the median over the absolute step sizes between data points."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
            <when value="flagZScore">
              <repeat name="field_repeat" title="Field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Name for field" help="List[str]&#10;List of variables names to process."/>
              </repeat>
              <param argument="method" type="select" value="standard" optional="true" label="Which method to use for ZScoring:" help="Which method to use for ZScoring:&#10;&#10;* `&quot;standard&quot;`: standard Zscoring, using *mean* for the expectation and *standard deviation (std)* as scaling factor&#10;* `&quot;modified&quot;`: modified Zscoring, using *median* as the expectation and *median absolute deviation (MAD)* as the scaling Factor&#10;&#10;See notes section for detailed scoring formula">
                <option value="standard">standard</option>
                <option value="modified">modified</option>
              </param>
              <conditional name="window_cond">
                <param name="window_select_type" type="select" value="none" optional="false" label="Size of the window. Input Mode">
                  <option value="number">Number</option>
                  <option value="timedelta">Timedelta</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Size of the window. (as number)" help="Size of the window. Either determined via an offset string, denoting the windows temporal&#10;extension or by an integer, denoting the windows number of periods. ``NaN`` also count as&#10;periods. If ``None`` is passed, all data points share the same scoring window, which than&#10;equals the whole data."/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Size of the window. (as timedelta string)" help="Size of the window. Either determined via an offset string, denoting the windows temporal&#10;extension or by an integer, denoting the windows number of periods. ``NaN`` also count as&#10;periods. If ``None`` is passed, all data points share the same scoring window, which than&#10;equals the whole data."/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="thresh" type="float" value="3" optional="true" label="Cutoff level for the Zscores, above which associated points are marked as out..." help="Cutoff level for the Zscores, above which associated points are marked as outliers."/>
              <param argument="min_residuals" type="integer" optional="true" label="Minimum residual value points must have to be considered outliers." help="Minimum residual value points must have to be considered outliers."/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of valid meassurements in a scoring window, to consider the re..." help="Minimum number of valid meassurements in a scoring window, to consider the resulting score valid."/>
              <param argument="--center" type="boolean" optional="true" label="Weather or not to center the target value in the scoring window." help="Weather or not to center the target value in the scoring window. If ``False``, the&#10;target value is the last value in the window." checked="true" truevalue="--center" falsevalue=""/>
              <param argument="axis" type="integer" value="0" optional="true" label="Along which axis to calculate the scoring statistics:" help="Along which axis to calculate the scoring statistics:&#10;&#10;* `0` (default) - calculate statistics along time axis&#10;* `1` - calculate statistics over multiple variables&#10;&#10;See Notes section for a visual clarification of the workings&#10;of `axis` and `window`."/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="pattern">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="flagPatternByDTW">flagPatternByDTW: Pattern Recognition via Dynamic Time Warping</option>
            </param>
            <when value="flagPatternByDTW">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="reference" type="text" value="" optional="false" label="The name in `data` which holds the pattern." help="The name in `data` which holds the pattern. The pattern must&#10;not have NaNs, have a datetime index and must not be empty."/>
              <param argument="max_distance" type="float" value="0.0" optional="true" label="Maximum dtw-distance between chunk and pattern, if the distance" help="Maximum dtw-distance between chunk and pattern, if the distance&#10;is lower than ``max_distance`` the data gets flagged. With&#10;default, ``0.0``, only exact matches are flagged."/>
              <param argument="--normalize" type="boolean" optional="true" label="If `False`, return unmodified distances." help="If `False`, return unmodified distances.&#10;If `True`, normalize distances by the number of observations&#10;of the reference. This helps to make it easier to find a&#10;good cutoff threshold for further processing. The distances&#10;then refer to the mean distance per datapoint, expressed&#10;in the datas units." checked="true" truevalue="--normalize" falsevalue=""/>
              <param argument="--plot" type="boolean" optional="true" label="Show a calibration plot, which can be quite helpful to find" help="Show a calibration plot, which can be quite helpful to find&#10;the right threshold for `max_distance`. It works best with&#10;`normalize=True`. Do not use in automatic setups / pipelines.&#10;The plot show three lines:&#10;&#10;- data: the data the function was called on&#10;- distances: the calculated distances by the algorithm&#10;- indicator: have to distinct levels: `0` and the value of&#10;`max_distance`. If `max_distance` is `0.0` it defaults to&#10;`1`. Everywhere where the indicator is not `0` the data&#10;will be flagged." checked="false" truevalue="--plot" falsevalue=""/>
              <param argument="flag" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;The flag value the function uses to mark observations. Defaults to the ``BAD`` value of the translation scheme."/>
            </when>
          </conditional>
        </when>
        <when value="resampling">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="concatFlags">concatFlags: Project flags/history of :py:attr:`field` to :py:attr:`target` and adjust to the frequeny grid</option>
              <option value="reindex">reindex: Change a variables index</option>
              <option value="resample">resample: Resample data points and flags to a regular frequency</option>
            </param>
            <when value="concatFlags">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="target" type="text" optional="true" label="str | list[str]" help="str | list[str]&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="method" type="select" value="auto" optional="true" label="Method to project the flags of :py:attr:`field` to the flags to :py:attr:`tar..." help="Method to project the flags of :py:attr:`field` to the flags to :py:attr:`target`:&#10;&#10;* ``'auto'``: invert the last alignment/resampling operation (that is not already inverted)&#10;* ``'nagg'``: project a flag of :py:attr:`field` to all timestamps of&#10;:py:attr:`target` within the range +/- :py:attr:`freq`/2.&#10;* ``'bagg'``: project a flag of :py:attr:`field` to all preceeding timestamps&#10;of :py:attr:`target` within the range :py:attr:`freq`&#10;* ``'fagg'``: project a flag of :py:attr:`field` to all succeeding timestamps&#10;of :py:attr:`target` within the range :py:attr:`freq`&#10;* ``'interpolation'`` - project a flag of :py:attr:`field` to all timestamps&#10;of :py:attr:`target` within the range +/- :py:attr:`freq`&#10;* ``'sshift'`` - same as interpolation&#10;* ``'nshift'`` - project a flag of :py:attr:`field` to the neaerest timestamps&#10;in :py:attr:`target` within the range +/- :py:attr:`freq`/2&#10;* ``'bshift'`` - project a flag of :py:attr:`field` to nearest preceeding&#10;timestamps in :py:attr:`target`&#10;* ``'nshift'`` - project a flag of :py:attr:`field` to nearest succeeding&#10;timestamps in :py:attr:`target`&#10;* ``'match'`` - project a flag of :py:attr:`field` to all identical timestamps&#10;:py:attr:`target`">
                <option value="fagg">fagg</option>
                <option value="bagg">bagg</option>
                <option value="nagg">nagg</option>
                <option value="fshift">fshift</option>
                <option value="bshift">bshift</option>
                <option value="nshift">nshift</option>
                <option value="sshift">sshift</option>
                <option value="match">match</option>
                <option value="auto">auto</option>
              </param>
              <param argument="--invert" type="boolean" optional="true" label="If True, not the actual method is applied, but its inversion-method." help="If True, not the actual method is applied, but its inversion-method." checked="true" truevalue="--invert" falsevalue=""/>
              <param argument="freq" type="text" optional="true" label="Projection range." help="Projection range. If ``None`` the sampling frequency of :py:attr:`field` is used."/>
              <param argument="--drop" type="boolean" optional="true" label="Remove :py:attr:`field` if ``True``" help="Remove :py:attr:`field` if ``True``" checked="false" truevalue="--drop" falsevalue=""/>
              <param argument="--squeeze" type="boolean" optional="true" label="Squeeze the history into a single column if ``True``, function specific flag ..." help="Squeeze the history into a single column if ``True``, function specific flag information is lost." checked="false" truevalue="--squeeze" falsevalue=""/>
              <param argument="--override" type="boolean" optional="true" label="Overwrite existing flags if ``True``" help="Overwrite existing flags if ``True``" checked="false" truevalue="--override" falsevalue=""/>
            </when>
            <when value="reindex">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="index" type="text" value="" optional="false" label="Determines the new index." help="Determines the new index.&#10;&#10;* If an `offset` string: new index will range from start to end of the original index of&#10;`field`, exhibting a uniform sampling rate of `idx`&#10;* If a `str` that matches a field present in the `SaQC` object, that fields index will be&#10;used as new index of `field`&#10;* If an `pd.index` object is passed, that will be the new index of `field`."/>
              <param argument="method" type="select" value="match" optional="true" label="Determines which of the origins indexes periods to comprise into the calculat..." help="Determines which of the origins indexes periods to comprise into the calculation of a new flag and a new data value at&#10;any period of the new index.&#10;&#10;* Aggregations Reindexer. Aggregations are data and flags independent, (pure) index selection methods:&#10;* `'bagg'`/`'fagg'`: &quot;backwards/forwards aggregation&quot;. Any new index period gets assigned an&#10;aggregation of the values at periods in the original index, that lie between itself and its successor/predecessor.&#10;* `'nagg'`: &quot;nearest aggregation&quot;: Any new index period gets assigned an aggregation of the values at periods&#10;in the original index between its direcet predecessor and successor, it is the nearest neighbor to.&#10;* Rolling reindexer. Rolling reindexers are equal to aggregations, when projecting between&#10;regular and irregular sampling grids forth and back. But due to there simple rolling window construction, they are&#10;easier to comprehend, predict and parametrize. On the downside, they are much more expensive computationally and&#10;Also, periods can get included in the aggregation to multpiple target periods, (when rolling windows overlap).&#10;* `'broll'`/`'froll'`: Any new index period gets assigned an aggregation of all the values at periods&#10;of the original index, that fall into a directly preceeding/succeeding window of size `reindex_window`.&#10;* Shifts. Shifting methods are shortcuts for aggregation reindex methods, combined with selecting&#10;'last' or 'first' as the `data_aggregation` method. Therefor, both, the `flags_aggregation`&#10;and the `data_aggregation` are ignored when using a `shift` reindexer. Also, periods&#10;where the data evaluates to `NaN` are dropped before shift index selection.&#10;* `'bshift'`/`fshift`: &quot;backwards/forwards shift&quot;. Any new index period gets assigned the&#10;first/last valid (not a data NaN) value it succeeds/preceeds&#10;* `'nshift'`: &quot;nearest shift&quot;: Any new index period gets assigned the value of its closest neighbor in the&#10;original index.&#10;* Pillar point Mappings. Index selection method designed to select indices suitable for&#10;linearly interpolating index values from surrounding pillar points in the original index, or inverting such&#10;a selection. Periods where the data evaluates to `NaN`, are dropped from consideration.&#10;* `'mshift'`: &quot;Merge&quot; predecessors and successors. Any new index period gets assigned an aggregation/interpolation comprising&#10;the last and the next valid period in the original index.&#10;* `'sshift'`: &quot;Split&quot;-map values onto predecessors and successors. Same as `mshift`, but with a correction that prevents missing value&#10;flags from being mapped to continuous data chunk bounds.&#10;* Inversion of last method: try to select the method, that&#10;* `'invert``">
                <option value="fagg">fagg</option>
                <option value="bagg">bagg</option>
                <option value="nagg">nagg</option>
                <option value="froll">froll</option>
                <option value="broll">broll</option>
                <option value="nroll">nroll</option>
                <option value="fshift">fshift</option>
                <option value="bshift">bshift</option>
                <option value="nshift">nshift</option>
                <option value="match">match</option>
                <option value="sshift">sshift</option>
                <option value="mshift">mshift</option>
                <option value="invert">invert</option>
              </param>
              <param argument="tolerance" type="text" optional="true" label="Limiting the distance, values can be shifted or comprised into aggregation." help="Limiting the distance, values can be shifted or comprised into aggregation."/>
              <param argument="data_aggregation" type="text" optional="true" label="Function string or custom Function, determining how to aggregate new data values" help="Function string or custom Function, determining how to aggregate new data values&#10;from the values at the periods selected according to the `index_selection_method`.&#10;If a scalar value is passed, the new data series will just evaluate to that scalar at any new index."/>
              <param argument="flags_aggregation" type="text" optional="true" label="Function string or custom Function, determining how to aggregate new flags va..." help="Function string or custom Function, determining how to aggregate new flags values&#10;from the values at the periods selected according to the `index_selection_method`.&#10;If a scalar value is passed, the new flags series will just evaluate to that scalar at any new index."/>
              <param argument="--broadcast" type="boolean" optional="true" label="Weather to propagate aggregation result to full reindex window when using agg..." help="Weather to propagate aggregation result to full reindex window when using aggregation reindexer.&#10;(as opposed to only assign to next/previous/closest)" checked="true" truevalue="--broadcast" falsevalue=""/>
              <param argument="--squeeze" type="boolean" optional="true" label="squeeze" help="" checked="false" truevalue="--squeeze" falsevalue=""/>
              <param argument="--override" type="boolean" optional="true" label="override" help="" checked="false" truevalue="--override" falsevalue=""/>
            </when>
            <when value="resample">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="freq" type="text" value="" optional="false" label="Offset string." help="Offset string. Sampling rate of the target frequency grid."/>
              <param argument="func" type="text" value="mean" optional="true" label="Aggregation function." help="Aggregation function. See notes for performance considerations."/>
              <param argument="method" type="select" value="bagg" optional="true" label="Specifies which intervals to be aggregated for a certain timestamp." help="Specifies which intervals to be aggregated for a certain timestamp. (preceding,&#10;succeeding or &quot;surrounding&quot; interval). See description above for more details.">
                <option value="fagg">fagg</option>
                <option value="bagg">bagg</option>
                <option value="nagg">nagg</option>
              </param>
              <param argument="maxna" type="integer" optional="true" label="Maximum number of allowed ``NaN``s in a resampling interval." help="Maximum number of allowed ``NaN``s in a resampling interval. If exceeded, the&#10;aggregation of the interval evaluates to ``NaN``."/>
              <param argument="maxna_group" type="integer" optional="true" label="Same as `maxna` but for consecutive NaNs." help="Same as `maxna` but for consecutive NaNs."/>
              <param argument="--squeeze" type="boolean" optional="true" label="squeeze" help="" checked="false" truevalue="--squeeze" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="residuals">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="calculatePolynomialResiduals">calculatePolynomialResiduals: Fits a polynomial model to the data and calculate the residuals</option>
              <option value="calculateRollingResiduals">calculateRollingResiduals: Calculate the diff of a rolling-window function and the data</option>
            </param>
            <when value="calculatePolynomialResiduals">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="The size of the window you want to use for fitting." help="The size of the window you want to use for fitting. If an integer is passed,&#10;the size refers to the number of periods for every fitting window. If an&#10;offset string is passed, the size refers to the total temporal extension. The&#10;window will be centered around the vaule-to-be-fitted. For regularly sampled&#10;timeseries the period number will be casted down to an odd number if even."/>
              <param argument="order" type="integer" value="" optional="false" label="The degree of the polynomial used for fitting" help="The degree of the polynomial used for fitting"/>
              <param argument="min_periods" type="integer" value="0" optional="true" label="The minimum number of periods, that has to be available in every values" help="The minimum number of periods, that has to be available in every values&#10;fitting surrounding for the polynomial fit to be performed. If there are not&#10;enough values, np.nan gets assigned. Default (0) results in fitting&#10;regardless of the number of values present (results in overfitting for too&#10;sparse intervals). To automatically set the minimum number of periods to the&#10;number of values in an offset defined window size, pass np.nan."/>
            </when>
            <when value="calculateRollingResiduals">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="The size of the window you want to roll with." help="The size of the window you want to roll with. If an integer is passed, the size&#10;refers to the number of periods for every fitting window. If an offset string&#10;is passed, the size refers to the total temporal extension. For regularly&#10;sampled timeseries, the period number will be casted down to an odd number if&#10;``center=True``."/>
              <param argument="func" type="text" value="mean" optional="true" label="default mean" help="default mean&#10;Function to roll with."/>
              <param argument="min_periods" type="integer" value="0" optional="true" label="The minimum number of periods to get a valid value" help="The minimum number of periods to get a valid value"/>
              <param argument="--center" type="boolean" optional="true" label="If True, center the rolling window." help="If True, center the rolling window." checked="true" truevalue="--center" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="rolling">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="rolling">rolling: Calculate a rolling-window function on the data</option>
            </param>
            <when value="rolling">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" value="" optional="false" label="The size of the window you want to roll with." help="The size of the window you want to roll with. If an integer is passed, the size&#10;refers to the number of periods for every fitting window. If an offset string&#10;is passed, the size refers to the total temporal extension. For regularly&#10;sampled timeseries, the period number will be casted down to an odd number if&#10;``center=True``."/>
              <param argument="func" type="text" value="mean" optional="true" label="default mean" help="default mean&#10;Function to roll with."/>
              <param argument="min_periods" type="integer" value="0" optional="true" label="The minimum number of periods to get a valid value" help="The minimum number of periods to get a valid value"/>
              <param argument="--center" type="boolean" optional="true" label="If True, center the rolling window." help="If True, center the rolling window." checked="true" truevalue="--center" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="scores">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="assignKNNScore">assignKNNScore: Score datapoints by an aggregation of the distances to their `k` nearest neighbors</option>
              <option value="assignLOF">assignLOF: Assign Local Outlier Factor (LOF)</option>
              <option value="assignUniLOF">assignUniLOF: Assign "univariate" Local Outlier Factor (LOF)</option>
              <option value="assignZScore">assignZScore: Calculate (rolling) Zscores</option>
            </param>
            <when value="assignKNNScore">
              <repeat name="field_repeat" title="Field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Name for field" help="List[str]&#10;List of variables names to process."/>
              </repeat>
              <param argument="target" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="n" type="integer" value="10" optional="true" label=":" help=":&#10;The number of nearest neighbors to which the distance is comprised in every datapoints scoring calculation."/>
              <param argument="func" type="text" value="sum" optional="true" label="default sum" help="default sum&#10;A function that assigns a score to every one dimensional array, containing the distances&#10;to every datapoints `n` nearest neighbors."/>
              <conditional name="freq_cond">
                <param name="freq_select_type" type="select" value="number" optional="false" label="Determines the segmentation of the data into partitions, the kNN algorithm is Input Mode">
                  <option value="number">Frequency as Value (float)</option>
                  <option value="offset">Frequency as Offset string</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="number">
                  <param argument="freq" type="float" value="inf" optional="false" label="Determines the segmentation of the data into partitions, the kNN algorithm is (Frequency as Value (float))" help="Determines the segmentation of the data into partitions, the kNN algorithm is&#10;applied onto individually.&#10;&#10;* ``np.inf``: Apply Scoring on whole data set at once&#10;* ``x`` &gt; 0 : Apply scoring on successive data chunks of periods length ``x``&#10;* Offset String : Apply scoring on successive partitions of temporal extension matching the passed offset&#10;string"/>
                </when>
                <when value="offset">
                  <param argument="freq" type="text" value="" optional="false" label="Determines the segmentation of the data into partitions, the kNN algorithm is (Frequency as Offset string)" help="Determines the segmentation of the data into partitions, the kNN algorithm is&#10;applied onto individually.&#10;&#10;* ``np.inf``: Apply Scoring on whole data set at once&#10;* ``x`` &gt; 0 : Apply scoring on successive data chunks of periods length ``x``&#10;* Offset String : Apply scoring on successive partitions of temporal extension matching the passed offset&#10;string"/>
                </when>
                <when value="none">
                  <param name="freq" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="2" optional="true" label="The minimum number of periods that have to be present in a window for the kNN..." help="The minimum number of periods that have to be present in a window for the kNN scoring&#10;to be applied. If the number of periods present is below `min_periods`, the score for the&#10;datapoints in that window will be np.nan."/>
              <param argument="algorithm" type="select" value="ball_tree" optional="true" label="The search algorithm to find each datapoints k nearest neighbors." help="The search algorithm to find each datapoints k nearest neighbors.&#10;The keyword just gets passed on to the underlying sklearn method.&#10;See reference [1] for more information on the algorithm.">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="metric" type="text" value="minkowski" optional="true" label="The metric the distances to any datapoints neighbors is computed with." help="The metric the distances to any datapoints neighbors is computed with. The default of `metric`&#10;together with the default of `p` result in the euclidian to be applied.&#10;The keyword just gets passed on to the underlying sklearn method.&#10;See reference [1] for more information on the algorithm."/>
              <param argument="p" type="integer" value="2" optional="true" label=":" help=":&#10;The grade of the metrice specified by parameter `metric`.&#10;The keyword just gets passed on to the underlying sklearn method.&#10;See reference [1] for more information on the algorithm."/>
            </when>
            <when value="assignLOF">
              <repeat name="field_repeat" title="Field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Name for field" help="List[str]&#10;List of variables names to process."/>
              </repeat>
              <param argument="target" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="n" type="integer" value="20" optional="true" label="Number of periods to be included into the LOF calculation." help="Number of periods to be included into the LOF calculation. Defaults to `20`, which is a value found to be&#10;suitable in the literature."/>
              <conditional name="freq_cond">
                <param name="freq_select_type" type="select" value="number" optional="false" label="Determines the segmentation of the data into partitions, the kNN algorithm is Input Mode">
                  <option value="number">Frequency as Value (float)</option>
                  <option value="offset">Frequency as Offset string</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="number">
                  <param argument="freq" type="float" value="inf" optional="false" label="Determines the segmentation of the data into partitions, the kNN algorithm is (Frequency as Value (float))" help="Determines the segmentation of the data into partitions, the kNN algorithm is&#10;applied onto individually."/>
                </when>
                <when value="offset">
                  <param argument="freq" type="text" value="" optional="false" label="Determines the segmentation of the data into partitions, the kNN algorithm is (Frequency as Offset string)" help="Determines the segmentation of the data into partitions, the kNN algorithm is&#10;applied onto individually."/>
                </when>
                <when value="none">
                  <param name="freq" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="2" optional="true" label="min_periods" help=""/>
              <param argument="algorithm" type="select" value="ball_tree" optional="true" label="Algorithm used for calculating the `n`-nearest neighbors needed for LOF calcu..." help="Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation.">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="2" optional="true" label="Degree of the metric (&quot;Minkowski&quot;), according to wich distance to neighbors i..." help="Degree of the metric (&quot;Minkowski&quot;), according to wich distance to neighbors is determined.&#10;Most important values are:&#10;&#10;* `1` - Manhatten Metric&#10;* `2` - Euclidian Metric"/>
            </when>
            <when value="assignUniLOF">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="n" type="integer" value="20" optional="true" label="Number of periods to be included into the LOF calculation." help="Number of periods to be included into the LOF calculation. Defaults to `20`, which is a value found to be&#10;suitable in the literature.&#10;&#10;* `n` determines the &quot;locality&quot; of an observation (its `n` nearest neighbors) and sets the upper limit of&#10;values of an outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n/2`&#10;may not be detected reliably.&#10;* The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outliers&#10;points. Higher values greatly increase numerical costs."/>
              <param argument="algorithm" type="select" value="ball_tree" optional="true" label="Algorithm used for calculating the `n`-nearest neighbors needed for LOF calcu..." help="Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation.">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="1" optional="true" label="Degree of the metric (&quot;Minkowski&quot;), according to wich distance to neighbors i..." help="Degree of the metric (&quot;Minkowski&quot;), according to wich distance to neighbors is determined.&#10;Most important values are:&#10;&#10;* `1` - Manhatten Metric&#10;* `2` - Euclidian Metric"/>
              <conditional name="density_cond">
                <param name="density_select_type" type="select" value="auto" optional="false" label="How to calculate the temporal distance/density for the variable-to-be-flagged. Mode">
                  <option value="auto">Automatic ('auto')</option>
                  <option value="float">Specific Value (float)</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="auto">
                  <param name="density" type="hidden" value="auto" label=""/>
                </when>
                <when value="float">
                  <param argument="density" type="float" value="" optional="false" label="How to calculate the temporal distance/density for the variable-to-be-flagged. (float value)" help="How to calculate the temporal distance/density for the variable-to-be-flagged.&#10;&#10;* float - introduces linear density with an increment equal to `density`&#10;* Callable - calculates the density by applying the function passed onto the variable to be flagged&#10;(passed as Series)."/>
                </when>
                <when value="none">
                  <param name="density" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="--fill_na" type="boolean" optional="true" label="If True, NaNs in the data are filled with a linear interpolation." help="If True, NaNs in the data are filled with a linear interpolation." checked="true" truevalue="--fill_na" falsevalue=""/>
            </when>
            <when value="assignZScore">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="window" type="text" optional="true" label="Size of the window." help="Size of the window. can be determined as:&#10;* Offset String, denoting the windows temporal extension&#10;* Integer, denoting the windows number of periods.&#10;* `None` (default), All data points share the same scoring window, which than equals the whole&#10;data."/>
              <param argument="norm_func" type="text" value="std" optional="true" label="default mean" help="default mean&#10;Function to calculate the scaling for every window"/>
              <param argument="model_func" type="text" value="mean" optional="true" label="default std" help="default std&#10;Function to calculate the center moment in every window."/>
              <param argument="--center" type="boolean" optional="true" label="Weather or not to center the target value in the scoring window." help="Weather or not to center the target value in the scoring window. If `False`, the&#10;target value is the last value in the window." checked="true" truevalue="--center" falsevalue=""/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of valid meassurements in a scoring window, to consider the re..." help="Minimum number of valid meassurements in a scoring window, to consider the resulting score valid."/>
            </when>
          </conditional>
        </when>
        <when value="tools">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="copyField">copyField: Make a copy of the data and flags of `field`</option>
              <option value="dropField">dropField: Drops field from the data and flags</option>
              <option value="flagByClick">flagByClick: Pop up GUI for adding or removing flags by selection of points in the data plot</option>
              <option value="plot">plot: Plot data and flags or store plot to file</option>
              <option value="renameField">renameField: Rename field in data and flags</option>
              <option value="selectTime">selectTime: Realizes masking within saqc</option>
            </param>
            <when value="copyField">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="target" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable name to which the results are written. :py:attr:`target` will be created if it does not exist. Defaults to :py:attr:`field`."/>
              <param argument="--overwrite" type="boolean" optional="true" label="overwrite target, if already existant." help="overwrite target, if already existant." checked="false" truevalue="--overwrite" falsevalue=""/>
            </when>
            <when value="dropField">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
            </when>
            <when value="flagByClick">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="max_gap" type="text" optional="true" label="If ``None``, all data points will be connected, resulting in long linear" help="If ``None``, all data points will be connected, resulting in long linear&#10;lines, in case of large data gaps. ``NaN`` values will be removed before&#10;plotting. If an offset string is passed, only points that have a distance&#10;below ``max_gap`` are connected via the plotting line."/>
              <param argument="gui_mode" type="select" value="GUI" optional="true" label="* ``&quot;GUI&quot;`` (default), spawns TK based pop-up GUI, enabling scrolling and bin..." help="* ``&quot;GUI&quot;`` (default), spawns TK based pop-up GUI, enabling scrolling and binding for subplots&#10;* ``&quot;overlay&quot;``, spawns matplotlib based pop-up GUI. May be less conflicting, but does not support&#10;scrolling or binding.">
                <option value="GUI">GUI</option>
                <option value="overlay">overlay</option>
              </param>
              <param argument="selection_marker_kwargs" type="text" optional="true" label="selection_marker_kwargs" help=""/>
              <param argument="dfilter" type="float" value="255.0" optional="true" label="Any, optional" help="Any, optional&#10;Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme."/>
            </when>
            <when value="plot">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="path" type="text" optional="true" label="If ``None`` is passed, interactive mode is entered; plots are shown immediatly" help="If ``None`` is passed, interactive mode is entered; plots are shown immediatly&#10;and a user need to close them manually before execution continues.&#10;If a filepath is passed instead, store-mode is entered and&#10;the plot is stored unter the passed location."/>
              <param argument="max_gap" type="text" optional="true" label="If ``None``, all data points will be connected, resulting in long linear" help="If ``None``, all data points will be connected, resulting in long linear&#10;lines, in case of large data gaps. ``NaN`` values will be removed before&#10;plotting. If an offset string is passed, only points that have a distance&#10;below ``max_gap`` are connected via the plotting line."/>
              <param argument="mode" type="text" value="oneplot" optional="true" label="How to process multiple variables to be plotted:" help="How to process multiple variables to be plotted:&#10;&#10;* `&quot;oneplot&quot;` : plot all variables with their flags in one axis (default)&#10;* `&quot;subplots&quot;` : generate subplot grid where each axis contains one variable plot with associated flags&#10;* `&quot;biplot&quot;` : plotting first and second variable in field against each other in a scatter plot  (point cloud)."/>
              <conditional name="history_cond">
                <param name="history_select_type" type="select" value="valid" optional="false" label="Discriminate the plotted flags with respect to the tests they originate from. Mode">
                  <option value="valid">Valid</option>
                  <option value="complete">Complete</option>
                  <option value="list">Custom List</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="valid">
                  <param name="history" type="hidden" value="valid" label=""/>
                </when>
                <when value="complete">
                  <param name="history" type="hidden" value="complete" label=""/>
                </when>
                <when value="list">
                  <param argument="history" type="text" value="" optional="false" label="Discriminate the plotted flags with respect to the tests they originate from. (comma-separated)" help="Discriminate the plotted flags with respect to the tests they originate from.&#10;&#10;* ``&quot;valid&quot;``: Only plot flags, that are not overwritten by subsequent tests.&#10;Only list tests in the legend, that actually contributed flags to the overall&#10;result.&#10;* ``None``: Just plot the resulting flags for one variable, without any historical&#10;and/or meta information.&#10;* list of strings: List of tests. Plot flags from the given tests, only.&#10;* ``complete`` (not recommended, deprecated): Plot all the flags set by any test, independently from them being removed or modified by&#10;subsequent modifications. (this means: plotted flags do not necessarily match with flags ultimately&#10;assigned to the data)"/>
                </when>
                <when value="none">
                  <param name="history" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="xscope" type="text" optional="true" label="Determine a chunk of the data to be plotted." help="Determine a chunk of the data to be plotted. ``xscope`` can be anything,&#10;that is a valid argument to the ``pandas.Series.__getitem__`` method."/>
              <param argument="yscope" type="text" optional="true" label="Either a tuple of 2 scalars that determines all plots' y-view limits, or a li..." help="Either a tuple of 2 scalars that determines all plots' y-view limits, or a list of those&#10;tuples, determining the different variables y-view limits (must match number of variables)&#10;or a dictionary with variables as keys and the y-view tuple as values."/>
              <param argument="marker_kwargs" type="text" optional="true" label="Keywords to modify flags marker appearance." help="Keywords to modify flags marker appearance. The markers are set via the&#10;`matplotlib.pyplot.scatter &lt;https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.scatter.html&gt;`_&#10;method and can have the options listed there.&#10;The following options are `saqc` specific:&#10;&#10;* ``&quot;cycleskip&quot;``: (int) start the cycle of shapes that are assigned any flag-type with a certain lag - defaults to ``0`` (no skip)"/>
              <param argument="plot_kwargs" type="text" optional="true" label="Keywords to modify the plot appearance." help="Keywords to modify the plot appearance. The plotting is delegated to&#10;`matplotlib.pyplot.plot &lt;https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.scatter.html&gt;`_, all options listed there are available. Additionally the following saqc specific configurations are possible:&#10;&#10;* ``&quot;alpha&quot;``: Either a scalar float in *[0,1]*, that determines all plots' transparencies, or&#10;a list of floats, matching the number of variables to plot.&#10;&#10;* ``&quot;linewidth&quot;``: Either single float in *[0,1]*, that determines the thickness of all plotted,&#10;or a list of floats, matching the number of variables to plot."/>
              <param argument="dfilter" type="float" value="inf" optional="true" label="Any, optional" help="Any, optional&#10;Defines which observations will be masked based on the already existing flags. Any data point with a flag equal or worse to this threshold will be passed as ``NaN`` to the function. Defaults to the ``DFILTER_ALL`` value of the translation scheme."/>
            </when>
            <when value="renameField">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="new_name" type="text" value="" optional="false" label="String, field is to be replaced with." help="String, field is to be replaced with."/>
            </when>
            <when value="selectTime">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="mode" type="select" value="" optional="false" label="The masking mode." help="The masking mode.&#10;- &quot;periodic&quot;: parameters &quot;period_start&quot;, &quot;end&quot; are evaluated to generate a periodical mask&#10;- &quot;mask_var&quot;: data[mask_var] is expected to be a boolean valued timeseries and is used as mask.">
                <option value="periodic">periodic</option>
                <option value="selection_field">selection_field</option>
              </param>
              <param argument="selection_field" type="text" optional="true" label="Only effective if mode == &quot;mask_var&quot;" help="Only effective if mode == &quot;mask_var&quot;&#10;Fieldname of the column, holding the data that is to be used as mask. (must be boolean series)&#10;Neither the series` length nor its labels have to match data[field]`s index and length. An inner join of the&#10;indices will be calculated and values get masked where the values of the inner join are ``True``."/>
              <param argument="start" type="text" optional="true" label="Only effective if mode == &quot;seasonal&quot;" help="Only effective if mode == &quot;seasonal&quot;&#10;String denoting starting point of every period. Formally, it has to be a truncated instance of &quot;mm-ddTHH:MM:SS&quot;.&#10;Has to be of same length as `end` parameter.&#10;See examples section below for some examples."/>
              <param argument="end" type="text" optional="true" label="Only effective if mode == &quot;periodic&quot;" help="Only effective if mode == &quot;periodic&quot;&#10;String denoting starting point of every period. Formally, it has to be a truncated instance of &quot;mm-ddTHH:MM:SS&quot;.&#10;Has to be of same length as `end` parameter.&#10;See examples section below for some examples."/>
              <param argument="--closed" type="boolean" optional="true" label="Wheather or not to include the mask defining bounds to the mask." help="Wheather or not to include the mask defining bounds to the mask." checked="true" truevalue="--closed" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="transformation">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" optional="false" label="Method">
              <option value="transform">transform: Transform data by applying a custom function on data chunks of variable size. Existing flags are preserved</option>
            </param>
            <when value="transform">
              <param argument="field" type="text" value="" optional="false" label="str | list[str]" help="str | list[str]&#10;Variable to process."/>
              <param argument="func" type="text" value="" optional="false" label="Transformation function." help="Transformation function."/>
              <conditional name="freq_cond">
                <param name="freq_select_type" type="select" value="none" optional="false" label="Size of the data window. Input Mode">
                  <option value="number">Frequency as Value (float)</option>
                  <option value="offset">Frequency as Offset string</option>
                  <option value="none">None (use default)</option>
                </param>
                <when value="number">
                  <param argument="freq" type="float" value="" optional="false" label="Size of the data window. (Frequency as Value (float))" help="Size of the data window. The transformation is applied on each window individually&#10;&#10;* ``None``: Apply transformation on the entire data set at once&#10;* ``int`` : Apply transformation on successive data chunks of the given length. Must be grater than 0.&#10;* Offset String : Apply transformation on successive data chunks of the given temporal extension."/>
                </when>
                <when value="offset">
                  <param argument="freq" type="text" value="" optional="false" label="Size of the data window. (Frequency as Offset string)" help="Size of the data window. The transformation is applied on each window individually&#10;&#10;* ``None``: Apply transformation on the entire data set at once&#10;* ``int`` : Apply transformation on successive data chunks of the given length. Must be grater than 0.&#10;* Offset String : Apply transformation on successive data chunks of the given temporal extension."/>
                </when>
                <when value="none">
                  <param name="freq" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
            </when>
          </conditional>
        </when>
      </conditional>
    </repeat>
  </inputs>
  <outputs>
    <data name="output" format="csv" label="${tool.name} on ${on_string}: Processed Data" from_work_dir="output.csv" hidden="false"/>
    <collection name="plots" type="list" label="${tool.name} on ${on_string}: Plots (if any generated)">
      <discover_datasets pattern="(?P&lt;name&gt;.*)\.png" ext="png" visible="true"/>
    </collection>
    <data name="config_out" format="txt" label="${tool.name} on ${on_string}: Generated SaQC Configuration" from_work_dir="config.csv" hidden="false"/>
  </outputs>
  <expand macro="saqc_tests"/>
  <help><![CDATA[This tool provides access to SaQC functions for quality control of time series data. Select a module and method, then configure its parameters.]]></help>
  <expand macro="citations"/>
</tool>

