<tool name="SaQC" id="saqc" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="22.01">
  <description>quality control pipelines for environmental sensor data</description>
  <macros>
    <import>macros.xml</import>
  </macros>
  <expand macro="requirements"/>
  <version_command><![CDATA[python -c 'import saqc; print(saqc.__version__)']]></version_command>
  <node><![CDATA['
$
_
_
t
o
o
l
_
d
i
r
e
c
t
o
r
y
_
_
'
/
j
s
o
n
_
t
o
_
s
a
q
c
_
c
o
n
f
i
g
.
p
y
 
'
$
p
a
r
a
m
_
c
o
n
f
'
 
>
 
c
o
n
f
i
g
.
c
s
v
 
&
&


#
f
o
r
 
$
i
,
 
$
d
 
i
n
 
e
n
u
m
e
r
a
t
e
(
$
d
a
t
a
)


 
 
 
 
#
#
 
T
O
D
O
 
m
a
y
b
e
 
l
i
n
k
 
t
o
 
e
l
e
m
e
n
t
_
i
d
e
n
t
i
f
i
e
r


 
 
 
 
l
n
 
-
s
 
'
$
d
'
 
'
$
{
i
}
.
c
s
v
'
 
&
&


#
e
n
d
 
f
o
r


s
a
q
c
 
-
-
c
o
n
f
i
g
 
c
o
n
f
i
g
.
c
s
v
 


#
f
o
r
 
$
i
,
 
$
d
 
i
n
 
e
n
u
m
e
r
a
t
e
(
$
d
a
t
a
)


 
 
 
 
-
-
d
a
t
a
 
'
$
{
i
}
.
c
s
v
'
 


#
e
n
d
 
f
o
r


-
-
o
u
t
f
i
l
e
 
o
u
t
p
u
t
.
c
s
v]]></node>
  <configfiles>
    <inputs name="param_conf"/>
  </configfiles>
  <inputs>
    <param argument="--data" type="data" label="Input table" format="csv" multiple="true"/>
    <repeat name="methods_repeat" title="Methods">
      <conditional name="module_cond" label="Module">
        <param name="module_select" type="select" label="saqc module">
          <option value="breaks">breaks: Detecting breaks in data</option>
          <option value="changepoints">changepoints: changepoints</option>
          <option value="constants">constants: constants</option>
          <option value="curvefit">curvefit: curvefit</option>
          <option value="drift">drift: drift</option>
          <option value="flagtools">flagtools: flagtools</option>
          <option value="generic">generic: generic</option>
          <option value="interpolation">interpolation: interpolation</option>
          <option value="noise">noise: noise</option>
          <option value="outliers">outliers: outliers</option>
          <option value="pattern">pattern: pattern</option>
          <option value="resampling">resampling: resampling</option>
          <option value="residuals">residuals: residuals</option>
          <option value="rolling">rolling: rolling</option>
          <option value="scores">scores: scores</option>
          <option value="tools">tools: tools</option>
          <option value="transformation">transformation: transformation</option>
        </param>
        <when value="breaks">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="flagIsolated">flagIsolated: Find and flag temporal isolated groups of data</option>
              <option value="flagJumps">flagJumps: Flag jumps and drops in data</option>
              <option value="flagMissing">flagMissing: Flag NaNs in data</option>
            </param>
            <when value="flagIsolated">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="gap_window" type="text" value="" optional="false" label="Minimum gap size required before and after a data group to consider it" help="isolated. See condition (2) and (3)" space_between_arg="="/>
              <param argument="group_window" type="text" value="" optional="false" label="Maximum size of a data chunk to consider it a candidate for an isolated group" help="Data chunks that are bigger than the :py:attr:`group_window` are ignored.&#10;    This does not include the possible gaps surrounding it.&#10;    See condition (1)." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagJumps">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="thresh" type="float" value="" optional="false" label="Threshold value by which the mean of data has to jump, to trigger flagging" help="" space_between_arg="="/>
              <param argument="window" type="text" value="" optional="false" label="Size of the two moving windows" help="calculating the mean in every window. The window size should be big enough to yield enough&#10;    samples for a reliable mean calculation, but it should also not be arbitrarily big, since&#10;    it also limits the density of jumps that can be detected.&#10;    More precisely: Jumps that are not distanced to each other by more than three fourth (3/4)&#10;    of the selected :py:attr:`window` size, will not be detected reliably." space_between_arg="="/>
              <param argument="min_periods" type="integer" value="1" optional="false" label="The minimum number of observations in :py:attr:`window` required to calculate a valid mean value" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
              <param argument="dfilter" type="float" value="-inf" optional="false" label="Defines which observations will be masked based on the already existing flags" help="" space_between_arg="="/>
            </when>
            <when value="flagMissing">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
              <param argument="dfilter" type="float" value="-inf" optional="false" label="Defines which observations will be masked based on the already existing flags" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="changepoints">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="assignChangePointCluster">assignChangePointCluster: Label data where it changes significantly</option>
              <option value="flagChangePoints">flagChangePoints: Flag values that represent a system state transition</option>
            </param>
            <when value="assignChangePointCluster">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="stat_func" type="text" value="" optional="false" label="A function that assigns a value to every twin window" help="be passed to first variable,&#10;    right window content will be passed to the second.function ([&lt;class 'numpy.ndarray'&gt;, &lt;class 'numpy.ndarray'&gt;], &lt;class 'float'&gt;) (default: )" space_between_arg="="/>
              <param argument="thresh_func" type="text" value="" optional="false" label="A function that determines the value level, exceeding wich qualifies a" help="timestamps func value as denoting a changepoint.function ([&lt;class 'numpy.ndarray'&gt;, &lt;class 'numpy.ndarray'&gt;], &lt;class 'float'&gt;) (default: )" space_between_arg="="/>
              <param argument="window" type="text" value="" optional="false" label="Size of the rolling windows the calculation is performed in" help="frequency offset, it applies for the backward- and the forward-facing window.&#10;    &#10;    If two offsets (as a tuple) is passed the first defines the size of the&#10;    backward facing window, the second the size of the forward facing window." space_between_arg="="/>
              <param argument="min_periods" type="text" value="" optional="false" label="Minimum number of observations in a window required to perform the changepoint" help="test. If it is a tuple of two int, the first refer to the backward-,&#10;    the second to the forward-facing window." space_between_arg="="/>
              <param argument="reduce_window" type="text" optional="true" label="The sliding window search method is not an exact CP search method and usually" help="there won't be detected a single changepoint, but a &quot;region&quot; of change around&#10;    a changepoint. If `reduce_window` is given, for every window of size&#10;    `reduce_window`, there will be selected the value with index `reduce_func(x,&#10;    y)` and the others will be dropped. If `reduce_window` is None, the reduction&#10;    window size equals the twin window size, the changepoints have been detected&#10;    with." space_between_arg="="/>
              <param argument="reduce_func" type="text" value="" optional="false" label="A function that must return an index value upon input of two arrays x and y" help="First input parameter will hold the result from the stat_func evaluation for&#10;    every reduction window. Second input parameter holds the result from the&#10;    thresh_func evaluation. The default reduction function just selects the value&#10;    that maximizes the stat_func.function ([&lt;class 'numpy.ndarray'&gt;, &lt;class 'numpy.ndarray'&gt;], &lt;class 'float'&gt;) (default: &lt;function ChangepointsMixin.&lt;lambda&gt; at 0x7ce95c3c87c0&gt;)" space_between_arg="="/>
              <param argument="model_by_resids" type="boolean" label="If True, the results of `stat_funcs` are written, otherwise the regime labels" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
            <when value="flagChangePoints">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="stat_func" type="text" value="" optional="false" label="A function that assigns a value to every twin window" help="window content will be passed as the first array, the forward-facing window&#10;    content as the second.function ([&lt;class 'numpy.ndarray'&gt;, &lt;class 'numpy.ndarray'&gt;], &lt;class 'float'&gt;) (default: )" space_between_arg="="/>
              <param argument="thresh_func" type="text" value="" optional="false" label="A function that determines the value level, exceeding wich qualifies a" help="timestamps func value as denoting a change-point.function ([&lt;class 'numpy.ndarray'&gt;, &lt;class 'numpy.ndarray'&gt;], &lt;class 'float'&gt;) (default: )" space_between_arg="="/>
              <param argument="window" type="text" value="" optional="false" label="Size of the moving windows" help="calculating the statistic.&#10;    &#10;    If it is a single frequency offset, it applies for the backward- and the&#10;    forward-facing window.&#10;    &#10;    If two offsets (as a tuple) is passed the first defines the size of the&#10;    backward facing window, the second the size of the forward facing window." space_between_arg="="/>
              <param argument="min_periods" type="text" value="" optional="false" label="Minimum number of observations in a window required to perform the changepoint" help="test. If it is a tuple of two int, the first refer to the backward-,&#10;    the second to the forward-facing window." space_between_arg="="/>
              <param argument="reduce_window" type="text" optional="true" label="The sliding window search method is not an exact CP search method and usually" help="there wont be detected a single changepoint, but a &quot;region&quot; of change around&#10;    a changepoint.&#10;    &#10;    If `reduce_window` is given, for every window of size `reduce_window`, there&#10;    will be selected the value with index `reduce_func(x, y)` and the others will&#10;    be dropped.&#10;    &#10;    If `reduce_window` is None, the reduction window size equals the twin window&#10;    size, the changepoints have been detected with." space_between_arg="="/>
              <param argument="reduce_func" type="text" value="" optional="false" label="A function that must return an index value upon input of two arrays x and y" help="First input parameter will hold the result from the stat_func evaluation for&#10;    every reduction window. Second input parameter holds the result from the&#10;    `thresh_func` evaluation.&#10;    The default reduction function just selects the value that maximizes the&#10;    `stat_func`.function ([&lt;class 'numpy.ndarray'&gt;, &lt;class 'numpy.ndarray'&gt;], &lt;class 'int'&gt;) (default: &lt;function ChangepointsMixin.&lt;lambda&gt; at 0x7ce95c3c85e0&gt;)" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="constants">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="flagByVariance">flagByVariance: Flag low-variance data</option>
              <option value="flagConstants">flagConstants: Flag constant data values</option>
            </param>
            <when value="flagByVariance">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="window" type="text" value="" optional="false" label="Size of the moving window" help="for calculating the statistic. Each window will be a fixed size.&#10;    If its an offset then this will be the time period of each window.&#10;    Each window will be sized, based on the number of observations included&#10;    in the time-period." space_between_arg="="/>
              <param argument="thresh" type="float" value="" optional="false" label="Maximum total variance allowed per window" help="" space_between_arg="="/>
              <param argument="maxna" type="integer" optional="true" label="Maximum number of NaNs allowed in window" help="If more NaNs are present, the window is not flagged." space_between_arg="="/>
              <param argument="maxna_group" type="integer" optional="true" label="Same as `maxna` but for consecutive NaNs" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagConstants">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="thresh" type="float" value="" optional="false" label="Maximum total change allowed per window" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Size of the moving window" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Size of the moving window" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="2" optional="false" label="Minimum number of observations in window required to generate" help="a flag. This can be used to exclude underpopulated *offset* defined windows from&#10;    flagging. (Integer defined windows will always contain exactly *window* samples).&#10;    Must be an integer greater or equal `2`, because a&#10;    single value would always be considered constant.&#10;    Defaults to `2`." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="curvefit">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="fitLowpassFilter">fitLowpassFilter: Fits the data using the butterworth filter</option>
              <option value="fitPolynomial">fitPolynomial: Fits a polynomial model to the data</option>
            </param>
            <when value="fitLowpassFilter">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="cutoff_cond">
                <param name="cutoff_select" type="select" label="cutoff input mode">
                  <option value="number">Give as multiple of sampling rate</option>
                  <option value="offset">specify as offset</option>
                </param>
                <when value="number">
                  <param argument="cutoff" type="float" value="" optional="false" label="The cutoff-frequency, either an offset freq string, or expressed in multiples of the sampling rate" help="Multiple of sampling rate" space_between_arg="="/>
                </when>
                <when value="offset">
                  <param argument="cutoff" type="text" value="" optional="false" label="The cutoff-frequency, either an offset freq string, or expressed in multiples of the sampling rate" help="offset frequency string" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="nyq" type="float" value="0.5" optional="false" label="The niquist-frequency" help="" space_between_arg="="/>
              <param argument="filter_order" type="integer" value="2" optional="false" label="filter_order" help="" space_between_arg="="/>
              <param argument="fill_method" type="select" value="linear" optional="false" label="Fill method to be applied on the data before filtering (butterfilter cant" help="handle ''np.nan''). See documentation of pandas.Series.interpolate method for&#10;    details on the methods associated with the different keywords." space_between_arg="=">
                <option value="linear">linear</option>
                <option value="nearest">nearest</option>
                <option value="zero">zero</option>
                <option value="slinear">slinear</option>
                <option value="quadratic">quadratic</option>
                <option value="cubic">cubic</option>
                <option value="spline">spline</option>
                <option value="barycentric">barycentric</option>
                <option value="polynomial">polynomial</option>
              </param>
            </when>
            <when value="fitPolynomial">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Size of the window you want to use for fitting" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Size of the window you want to use for fitting" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="order" type="integer" value="" optional="false" label="Degree of the polynomial used for fitting" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" value="0" optional="false" label="Minimum number of observations in a window required to perform the fit," help="otherwise NaNs will be assigned.&#10;    If ``None``, `min_periods` defaults to 1 for integer windows and to the&#10;    size of the window for offset based windows.&#10;    Passing 0, disables the feature and will result in over-fitting for too&#10;    sparse windows." space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="drift">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="assignRegimeAnomaly">assignRegimeAnomaly: A function to detect values belonging to an anomalous regime regarding modelling</option>
              <option value="correctDrift">correctDrift: The function corrects drifting behavior</option>
              <option value="correctOffset">correctOffset: Parameters</option>
              <option value="correctRegimeAnomaly">correctRegimeAnomaly: Function fits the passed model to the different regimes in data[field] and tries to correct</option>
              <option value="flagDriftFromNorm">flagDriftFromNorm: Flags data that deviates from an avarage data course</option>
              <option value="flagDriftFromReference">flagDriftFromReference: Flags data that deviates from a reference course. Deviation is measured by a</option>
              <option value="flagRegimeAnomaly">flagRegimeAnomaly: Flags anomalous regimes regarding to modelling regimes of ``field``</option>
            </param>
            <when value="assignRegimeAnomaly">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="cluster_field" type="text" value="" optional="false" label="Column in data, holding the cluster labels for the samples in field" help="(has to be indexed equal to field)" space_between_arg="="/>
              <param argument="spread" type="float" value="" optional="false" label="A threshold denoting the value level, up to wich clusters a agglomerated" help="" space_between_arg="="/>
              <param argument="method" type="select" value="single" optional="false" label="The linkage method for hierarchical (agglomerative) clustering of the variables" help="" space_between_arg="=">
                <option value="single">single</option>
                <option value="complete">complete</option>
                <option value="average">average</option>
                <option value="weighted">weighted</option>
                <option value="centroid">centroid</option>
                <option value="median">median</option>
                <option value="ward">ward</option>
              </param>
              <param argument="metric" type="text" value="" optional="false" label="A metric function for calculating the dissimilarity between 2 regimes" help="Defaults to the absolute difference in mean.function ([&lt;class 'numpy.ndarray'&gt;, &lt;class 'numpy.ndarray'&gt;], &lt;class 'float'&gt;) (default: &lt;function DriftMixin.&lt;lambda&gt; at 0x7ce958e160c0&gt;)" space_between_arg="="/>
              <param argument="frac" type="float" value="0.5" optional="false" label="The minimum percentage of samples, the &quot;normal&quot; group has to comprise to" help="actually be the normal group. Must be in the closed interval `[0,1]`,&#10;    otherwise a ValueError is raised." space_between_arg="="/>
            </when>
            <when value="correctDrift">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="maintenance_field" type="text" value="" optional="false" label="Column holding the support-points information" help="The data is expected to have the following form:&#10;    The index of the series represents the beginning of a maintenance&#10;    event, wheras the values represent its endings." space_between_arg="="/>
              <conditional name="model_cond">
                <param name="model_select" type="select" label="Model function">
                  <option value="linear">linear</option>
                  <option value="exponential">exponential</option>
                  <option value="custom">custom</option>
                </param>
                <when value="linear"/>
                <when value="exponential"/>
                <when value="custom">
                  <param argument="model" type="text" value="" optional="false" label="A model function describing the drift behavior, that is to be corrected" help="Either use built-in exponential or linear drift model by passing a string,&#10;    or pass a custom callable. The model function must always contain the keyword&#10;    parameters 'origin' and 'target'. The starting parameter must always be the&#10;    parameter, by wich the data is passed to the model. After the data parameter,&#10;    there can occure an arbitrary number of model calibration arguments in the&#10;    signature. See the Notes section for an extensive description." space_between_arg="="/>
                </when>
              </conditional>
              <param argument="cal_range" type="integer" value="5" optional="false" label="Number of values to calculate the mean of, for obtaining the value level directly" help="after and directly before a maintenance event. Needed for shift calibration." space_between_arg="="/>
            </when>
            <when value="correctOffset">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="max_jump" type="float" value="" optional="false" label="when searching for changepoints in mean - this is the threshold a mean difference in the" help="sliding window search must exceed to trigger changepoint detection." space_between_arg="="/>
              <param argument="spread" type="float" value="" optional="false" label="threshold denoting the maximum, regimes are allowed to abolutely differ in their means" help="to form the &quot;normal group&quot; of values." space_between_arg="="/>
              <param argument="window" type="text" value="" optional="false" label="Size of the adjacent windows that are used to search for the mean changepoints" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" value="" optional="false" label="Minimum number of periods a search window has to contain, for the result of the changepoint" help="detection to be considered valid." space_between_arg="="/>
              <param argument="tolerance" type="text" optional="true" label="If an offset string is passed, a data chunk of length `offset` right from the" help="start and right before the end of any regime is ignored when calculating a regimes mean for data correcture.&#10;    This is to account for the unrelyability of data near the changepoints of regimes." space_between_arg="="/>
            </when>
            <when value="correctRegimeAnomaly">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="cluster_field" type="text" value="" optional="false" label="A string denoting the field in data, holding the cluster label for the data you want" help="to correct." space_between_arg="="/>
              <param argument="tolerance" type="text" optional="true" label="If an offset string is passed, a data chunk of length `offset` right at the" help="start and right at the end is ignored when fitting the model. This is to&#10;    account for the unreliability of data near the changepoints of regimes.&#10;    Defaults to None." space_between_arg="="/>
              <param argument="epoch" type="boolean" label="If True, use &quot;seconds from epoch&quot; as x input to the model func, instead of" help="&quot;seconds from regime start&quot;." checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
            <when value="flagDriftFromNorm">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="window" type="text" value="" optional="false" label="Frequency, that split the data in chunks" help="" space_between_arg="="/>
              <param argument="spread" type="float" value="" optional="false" label="Maximum spread allowed in the group of *normal* data" help="" space_between_arg="="/>
              <param argument="frac" type="float" value="0.5" optional="false" label="Fraction defining the normal group" help="The higher the value, the more stable the algorithm will be. For values below&#10;    0.5 the results are undefined." space_between_arg="="/>
              <param argument="metric" type="text" value="" optional="false" label="Distance function that takes two arrays as input and returns a scalar float" help="This value is interpreted as the distance of the two input arrays.&#10;    Defaults to the `averaged manhattan metric` (see Notes).function ([numpy.ndarray | pandas.core.series.Series, numpy.ndarray | pandas.core.series.Series], &lt;class 'numpy.ndarray'&gt;) (default: &lt;function cityblock at 0x7ce958e15260&gt;)" space_between_arg="="/>
              <param argument="method" type="select" value="single" optional="false" label="Linkage method used for hierarchical (agglomerative) clustering of the data" help="`method` is directly passed to ``scipy.hierarchy.linkage``. See its documentation [1] for&#10;    more details. For a general introduction on hierarchical clustering see [2]." space_between_arg="=">
                <option value="single">single</option>
                <option value="complete">complete</option>
                <option value="average">average</option>
                <option value="weighted">weighted</option>
                <option value="centroid">centroid</option>
                <option value="median">median</option>
                <option value="ward">ward</option>
              </param>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagDriftFromReference">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="reference" type="text" value="" optional="false" label="Reference variable, the deviation is calculated from" help="" space_between_arg="="/>
              <param argument="freq" type="text" value="" optional="false" label="Frequency, that split the data in chunks" help="" space_between_arg="="/>
              <param argument="thresh" type="float" value="" optional="false" label="Maximum deviation from reference" help="" space_between_arg="="/>
              <param argument="metric" type="text" value="" optional="false" label="Distance function" help="This value is interpreted as the mutual distance of the two input arrays.&#10;    Defaults to the `averaged manhattan metric` (see Notes).function ([numpy.ndarray | pandas.core.series.Series, numpy.ndarray | pandas.core.series.Series], &lt;class 'numpy.ndarray'&gt;) (default: &lt;function cityblock at 0x7ce958e15260&gt;)" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagRegimeAnomaly">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="cluster_field" type="text" value="" optional="false" label="Column in data, holding the cluster labels for the samples in field" help="(has to be indexed equal to field)" space_between_arg="="/>
              <param argument="spread" type="float" value="" optional="false" label="A threshold denoting the value level, up to wich clusters a agglomerated" help="" space_between_arg="="/>
              <param argument="method" type="select" value="single" optional="false" label="The linkage method for hierarchical (agglomerative) clustering of the variables" help="" space_between_arg="=">
                <option value="single">single</option>
                <option value="complete">complete</option>
                <option value="average">average</option>
                <option value="weighted">weighted</option>
                <option value="centroid">centroid</option>
                <option value="median">median</option>
                <option value="ward">ward</option>
              </param>
              <param argument="metric" type="text" value="" optional="false" label="A metric function for calculating the dissimilarity between 2 regimes" help="Defaults to the absolute difference in mean.function ([numpy.ndarray | pandas.core.series.Series, numpy.ndarray | pandas.core.series.Series], &lt;class 'float'&gt;) (default: &lt;function DriftMixin.&lt;lambda&gt; at 0x7ce958e15f80&gt;)" space_between_arg="="/>
              <param argument="frac" type="float" value="0.5" optional="false" label="The minimum percentage of samples, the &quot;normal&quot; group has to comprise to" help="actually be the normal group. Must be in the closed interval `[0,1]`,&#10;    otherwise a ValueError is raised." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="flagtools">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="andGroup">andGroup: Flag all values, if all the given ``field`` values are already flagged</option>
              <option value="clearFlags">clearFlags: Assign UNFLAGGED value to all periods in field</option>
              <option value="flagDummy">flagDummy: Function does nothing but returning data and flags</option>
              <option value="flagManual">flagManual: Include flags listed in external data</option>
              <option value="flagUnflagged">flagUnflagged: Function sets a flag at all unflagged positions</option>
              <option value="forceFlags">forceFlags: Set whole column to a flag value</option>
              <option value="orGroup">orGroup: Flag all values, if at least one of the given ``field`` values is already flagged</option>
              <option value="propagateFlags">propagateFlags: Flag values before or after flags set by the last test</option>
              <option value="transferFlags">transferFlags: Transfer Flags of one variable to another</option>
            </param>
            <when value="andGroup">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <repeat name="target_repeat" title="target(s)" min="1">
                <param argument="target" type="text" optional="true" label="Variable name to which the results are written" help="" space_between_arg="="/>
              </repeat>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="clearFlags">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
            </when>
            <when value="flagDummy">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
            </when>
            <when value="flagManual">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="method" type="select" value="left-open" optional="false" label="Defines how :py:attr:`mdata` is projected to data:" help="* ``&quot;plain&quot;``: :py:attr:`mdata` must have the same length as :py:attr:`field`, flags&#10;      are set, where the values in :py:attr:`mdata` equal :py:attr:`mflag`.&#10;    * ``&quot;ontime&quot;``: Expects datetime indexed :py:attr:`mdata` (types ``pd.Series``,&#10;      ``pd.DataFrame``, ``DictOfSeries``). Flags are set, where the values in&#10;      :py:attr:`mdata` equal :py:attr:`mflag` and the indices of :py:attr:`field` and&#10;      :py:attr:`mdata` match.&#10;    * ``&quot;right-open&quot;``: Expects datetime indexed :py:attr:`mdata`, which will be interpreted&#10;      as a number of time intervals ``t_1, t_2``. Flags are set to all timestamps ``t`` of&#10;      :py:attr:`field` with ``t_1 &lt;= t &lt; t_2``.&#10;    * ``&quot;left-open&quot;``: like ``&quot;right-open&quot;``, but the interval covers all ``t`` with&#10;      ``t_1 &lt; t &lt;= t_2``.&#10;    * ``&quot;closed&quot;``: like ``&quot;right-open&quot;``, but the interval now covers all ``t`` with&#10;      ``t_1 &lt;= t &lt;= t_2``." space_between_arg="=">
                <option value="left-open">left-open</option>
                <option value="right-open">right-open</option>
                <option value="closed">closed</option>
                <option value="plain">plain</option>
                <option value="ontime">ontime</option>
              </param>
              <param argument="mformat" type="select" value="start-end" optional="false" label="Controls the interval definition in :py:attr:`mdata` (see examples):" help="* ``&quot;start-end&quot;``: expects datetime indexed :py:attr:`mdata` (types ``pd.Series``,&#10;      ``pd.DataFrame``, ``DictOfSeries``) with values of type datetime. Each&#10;      index-value pair is interpreted as an interval to flag, the index defines the&#10;      left bound, the respective value the right bound.&#10;    * ``&quot;mflag&quot;``:&#10;    &#10;      - :py:attr:`mdata` of type ``pd.Series``, ``pd.DataFrame``, ``DictOfSeries``:&#10;        Two successive index values ``i_1, i_2`` will be interpreted as an interval&#10;        ``t_1, t_2`` to flag, if the value of ``t_1`` equals :py:attr:`mflag`&#10;      - :py:attr:`mdata` of type ``list``, ``np.ndarray``: Flags all :py:attr:`field`&#10;        where :py:attr:`mdata` euqals :py:attr:`mflag`." space_between_arg="=">
                <option value="start-end">start-end</option>
                <option value="mflag">mflag</option>
              </param>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagUnflagged">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="forceFlags">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="flag" help="" space_between_arg="="/>
            </when>
            <when value="orGroup">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <repeat name="target_repeat" title="target(s)" min="1">
                <param argument="target" type="text" optional="true" label="Variable name to which the results are written" help="" space_between_arg="="/>
              </repeat>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="propagateFlags">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Size of the repetition window" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Size of the repetition window" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="method" type="select" value="ffill" optional="false" label="Direction of repetetion" help="receive the flag to repeat, with &quot;bfill&quot; the previous values." space_between_arg="=">
                <option value="ffill">ffill</option>
                <option value="bfill">bfill</option>
              </param>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
              <param argument="dfilter" type="float" value="-inf" optional="false" label="Defines which observations will be masked based on the already existing flags" help="" space_between_arg="="/>
            </when>
            <when value="transferFlags">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="target" type="text" optional="true" label="Variable name to which the results are written" help="" space_between_arg="="/>
              <param argument="squeeze" type="boolean" label="Squeeze the history into a single column if ``True``, function specific flag information is lost" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="overwrite" type="boolean" label="Overwrite existing flags if ``True``" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="generic">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="flagGeneric">flagGeneric: Flag data based on a given function</option>
              <option value="processGeneric">processGeneric: Generate/process data with user defined functions</option>
            </param>
            <when value="flagGeneric">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <repeat name="target_repeat" title="target(s)" min="1">
                <param argument="target" type="text" optional="true" label="Variable name to which the results are written" help="" space_between_arg="="/>
              </repeat>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="processGeneric">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <repeat name="target_repeat" title="target(s)" min="1">
                <param argument="target" type="text" optional="true" label="Variable name to which the results are written" help="" space_between_arg="="/>
              </repeat>
              <param argument="dfilter" type="float" value="-inf" optional="false" label="Defines which observations will be masked based on the already existing flags" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="interpolation">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="align">align: Convert time series to specified frequency. Values affected by</option>
              <option value="interpolateByRolling">interpolateByRolling: Replace NaN by the aggregation result of the surrounding window</option>
            </param>
            <when value="align">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="freq" type="text" value="" optional="false" label="Target frequency" help="" space_between_arg="="/>
              <param argument="method" type="text" value="time" optional="false" label="Interpolation technique to use" help="* ``'nshift'``: Shift grid points to the nearest time stamp&#10;      in the range = +/- 0.5 * ``freq``.&#10;    * ``'bshift'``: Shift grid points to the first succeeding&#10;      time stamp (if any).&#10;    * ``'fshift'``: Shift grid points to the last preceeding time&#10;      stamp (if any).&#10;    * ``'linear'``: Ignore the index and treat the values as equally&#10;      spaced.&#10;    * ``'time'``, ``'index'``, ``'values'``: Use the actual numerical&#10;      values of the index.&#10;    * ``'pad'``: Fill in NaNs using existing values.&#10;    * ``'spline'``, ``'polynomial'``:&#10;      Passed to ``scipy.interpolate.interp1d``. These methods&#10;      use the numerical values of the index.  An ``order`` must be&#10;      specified, e.g. ``qc.interpolate(method='polynomial', order=5)``.&#10;    * ``'nearest'``, ``'zero'``, ``'slinear'``, ``'quadratic'``, ``'cubic'``, ``'barycentric'``:&#10;      Passed to ``scipy.interpolate.interp1d``. These methods use&#10;      the numerical values of the index.&#10;    * ``'krogh'``, ``'spline'``, ``'pchip'``, ``'akima'``, ``'cubicspline'``:&#10;      Wrappers around the SciPy interpolation methods of similar&#10;      names.&#10;    * ``'from_derivatives'``: Refers to ``scipy.interpolate.BPoly.from_derivatives``." space_between_arg="="/>
              <param argument="order" type="integer" value="2" optional="false" label="Order of the interpolation method, ignored if not supported" help="by the chosen ``method``." space_between_arg="="/>
              <param argument="overwrite" type="boolean" label="If set to `True`, existing flags will be cleared" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
            <when value="interpolateByRolling">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="The size of the window, the aggregation is computed from" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="The size of the window, the aggregation is computed from" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="center" type="boolean" label="Center the window around the value" help="integer windows, otherwise it is silently ignored." checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="min_periods" type="integer" value="0" optional="false" label="Minimum number of valid (not np" help="available in a window for its aggregation to be&#10;    computed." space_between_arg="="/>
              <param argument="flag" type="float" value="-inf" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="noise">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="flagByScatterLowpass">flagByScatterLowpass: Flag data chunks of length ``window`` dependent on the data deviation</option>
              <option value="flagByStatLowPass">flagByStatLowPass: Flag data chunks of length ``window`` dependent on the data deviation</option>
            </param>
            <when value="flagByScatterLowpass">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="window" type="text" value="" optional="false" label="Window (i" help=" see: https://pandas.pydata.org/docs/user_guide/timedeltas.html#parsing" space_between_arg="="/>
              <param argument="thresh" type="float" value="" optional="false" label="Threshold" help="" space_between_arg="="/>
              <param argument="sub_window" type="text" optional="true" label="Window size of sub chunks, that are additionally tested for exceeding ``sub_thresh``" help="with respect to ``func``. see: https://pandas.pydata.org/docs/user_guide/timedeltas.html#parsing" space_between_arg="="/>
              <param argument="sub_thresh" type="float" optional="true" label="Threshold" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of values needed in a chunk to perfom the test" help="Ignored if ``window`` is an integer." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagByStatLowPass">
              <param argument="field" type="text" value="" optional="false" label="field" help="" space_between_arg="="/>
              <param argument="window" type="text" value="" optional="false" label="window" help=" see: https://pandas.pydata.org/docs/user_guide/timedeltas.html#parsing" space_between_arg="="/>
              <param argument="thresh" type="float" value="" optional="false" label="thresh" help="" space_between_arg="="/>
              <param argument="sub_window" type="text" optional="true" label="sub_window" help=" see: https://pandas.pydata.org/docs/user_guide/timedeltas.html#parsing" space_between_arg="="/>
              <param argument="sub_thresh" type="float" optional="true" label="sub_thresh" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" optional="true" label="min_periods" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="flag" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="outliers">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="flagByGrubbs">flagByGrubbs: Flag outliers using the Grubbs algorithm</option>
              <option value="flagByStray">flagByStray: Flag outliers in 1-dimensional (score) data using the STRAY Algorithm</option>
              <option value="flagLOF">flagLOF: Flag values where the Local Outlier Factor (LOF) exceeds cutoff</option>
              <option value="flagMAD">flagMAD: Flag outiers using the modified Z-score outlier detection method</option>
              <option value="flagMVScores">flagMVScores: The algorithm implements a 3-step outlier detection procedure for</option>
              <option value="flagOffset">flagOffset: A basic outlier test that works on regularly and irregularly sampled data</option>
              <option value="flagRaise">flagRaise: The function flags raises and drops in value courses, that exceed a certain threshold within a certain timespan</option>
              <option value="flagRange">flagRange: Function flags values exceeding the closed</option>
              <option value="flagUniLOF">flagUniLOF: Flag "univariate" Local Outlier Factor (LOF) exceeding cutoff</option>
              <option value="flagZScore">flagZScore: Flag data where its (rolling) Zscore exceeds a threshold</option>
            </param>
            <when value="flagByGrubbs">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Size of the testing window" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Size of the testing window" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="alpha" type="float" value="0.05" optional="false" label="Level of significance, the grubbs test is to be performed at" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" value="8" optional="false" label="Minimum number of values needed in a :py:attr:`window` in order to perform the grubs test" help="Ignored if :py:attr:`window` is an integer." space_between_arg="="/>
              <param argument="pedantic" type="boolean" label="If ``True``, every value gets checked twice" help="and second in a rolling window that is lagging by :py:attr:`window` / 2. Recommended to avoid&#10;    false positives at the window edges. Ignored if :py:attr:`window` is an offset string." checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagByStray">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="none">None</option>
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" optional="true" label="Determines the segmentation of the data into partitions, the" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" optional="true" label="Determines the segmentation of the data into partitions, the" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="11" optional="false" label="Minimum number of periods per partition that have to be present" help="for a valid outlier detection to be made in this partition" space_between_arg="="/>
              <param argument="iter_start" type="float" value="0.5" optional="false" label="Float in ``[0, 1]`` that determines which percentage of data" help="is considered &quot;normal&quot;. ``0.5`` results in the stray algorithm&#10;    to search only the upper 50% of the scores for the cut off&#10;    point. (See reference section for more information)" space_between_arg="="/>
              <param argument="alpha" type="float" value="0.05" optional="false" label="Level of significance by which it is tested, if a score might" help="be drawn from another distribution than the majority of the data." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagLOF">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="n" type="integer" value="20" optional="false" label="Number of neighbors to be included into the LOF calculation" help="Defaults to ``20``, which is a&#10;    value found to be suitable in the literature.&#10;    &#10;    * :py:attr:`n` determines the &quot;locality&quot; of an observation&#10;      (its :py:attr:`n` nearest neighbors) and sets the upper&#10;      limit to the number of values in outlier clusters (i.e.&#10;      consecutive outliers). Outlier clusters of size greater&#10;      than :py:attr:`n`/2 may not be detected reliably.&#10;    * The larger :py:attr:`n`, the lesser the algorithm's sensitivity&#10;      to local outliers and small or singleton outliers points.&#10;      Higher values greatly increase numerical costs." space_between_arg="="/>
              <conditional name="thresh_cond">
                <param name="thresh_select" type="select" label="thresh mode">
                  <option value="auto">automatic</option>
                  <option value="linear">linear</option>
                </param>
                <when value="auto">
                  <param name="thresh" type="hidden" value="auto" label=""/>
                </when>
                <when value="linear">
                  <param argument="thresh" type="float" value="1.5" optional="false" label="The threshold for flagging the calculated LOF" help="``1`` is considered normal and most likely corresponds to&#10;    inlier points.&#10;    &#10;    * The &quot;automatic&quot; threshing introduced with the publication&#10;      of the algorithm defaults to ``1.5``.&#10;    * In this implementation, :py:attr:`thresh` defaults (``'auto'``)&#10;      to flagging the scores with a modified 3-sigma rule." space_between_arg="="/>
                </when>
              </conditional>
              <param argument="algorithm" type="select" value="ball_tree" optional="false" label="Algorithm used for calculating the :py:attr:`n`-nearest neighbors" help="" space_between_arg="=">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="1" optional="false" label="Degree of the metric (&quot;Minkowski&quot;), according to which the" help="distance to neighbors is determined. Most important values are:&#10;    &#10;    * ``1`` - Manhattan Metric&#10;    * ``2`` - Euclidian Metric" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagMAD">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="none">None</option>
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" optional="true" label="Size of the window" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" optional="true" label="Size of the window" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="z" type="float" value="3.5" optional="false" label="The value the Z-score is tested against" help="" space_between_arg="="/>
              <param argument="min_residuals" type="integer" optional="true" label="min_residuals" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of valid meassurements in a scoring window, to consider the resulting score valid" help="" space_between_arg="="/>
              <param argument="center" type="boolean" label="Weather or not to center the target value in the scoring window" help="target value is the last value in the window." checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagMVScores">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="List of variables names to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="trafo" type="text" value="" optional="false" label="Transformation to be applied onto every column before scoring" help="fine-grained control, the data could also be transformed before&#10;    :py:meth:`~saqc.SaQC.flagMVScores` is called.function ([&lt;class 'pandas.core.series.Series'&gt;], &lt;class 'pandas.core.series.Series'&gt;) (default: &lt;function OutliersMixin.&lt;lambda&gt; at 0x7ce958e3e7a0&gt;)" space_between_arg="="/>
              <param argument="alpha" type="float" value="0.05" optional="false" label="Level of significance by which it is tested, if an observations score might" help="be drawn from another distribution than the majority of the data." space_between_arg="="/>
              <param argument="n" type="integer" value="10" optional="false" label="Number of neighbors included in the scoring process for every datapoint" help="" space_between_arg="="/>
              <param argument="iter_start" type="float" value="0.5" optional="false" label="Value in ``[0,1]`` that determines which percentage of data is considered" help="&quot;normal&quot;. 0.5 results in the threshing algorithm to search only the upper&#10;    50% of the scores for the cut-off point. (See reference section for more&#10;    information)" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="none">None</option>
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" optional="true" label="Only effective if :py:attr:`threshing` is set to ``'stray'``" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" optional="true" label="Only effective if :py:attr:`threshing` is set to ``'stray'``" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="11" optional="false" label="Only effective if :py:attr:`threshing` is set to ``'stray'`` and" help=":py:attr:`partition` is an integer. Minimum number of periods per&#10;    :py:attr:`partition` that have to be present for a valid outlier&#10;    detection to be made in this partition." space_between_arg="="/>
              <param argument="stray_range" type="text" optional="true" label="If not ``None``, it is tried to reduce the stray result onto single" help="outlier components of the input :py:attr:`field`. The offset string&#10;    denotes the range of the temporal surrounding to include into the MAD&#10;    testing while trying to reduce flags." space_between_arg="="/>
              <param argument="drop_flagged" type="boolean" label="Only effective when :py:attr:`stray_range` is not ``None``" help="not to drop flagged values from the temporal surroundings." checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="thresh" type="float" value="3.5" optional="false" label="Only effective when :py:attr:`stray_range` is not ``None``" help="'critical' value, controlling wheather the MAD score is considered&#10;    referring to an outlier or not. Higher values result in less rigid&#10;    flagging. The default value is widely considered apropriate in the&#10;    literature." space_between_arg="="/>
              <param argument="min_periods_r" type="integer" value="1" optional="false" label="Only effective when :py:attr:`stray_range` is not ``None``" help="number of measurements necessary in an interval to actually perform the&#10;    reduction step." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagOffset">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="tolerance" type="float" value="" optional="false" label="Maximum difference allowed between the value, directly preceding and the value directly" help="succeeding an offset to trigger flagging of the offsetting values. See condition (4)." space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="Maximum length allowed for offset value courses, to trigger flagging of the offsetting values" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="Maximum length allowed for offset value courses, to trigger flagging of the offsetting values" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="thresh" type="float" optional="true" label="Minimum difference between a value and its successors, to consider the successors an anomalous" help="offset group. See condition (1). If ``None``, condition (1) is not tested." space_between_arg="="/>
              <param argument="thresh_relative" type="float" optional="true" label="Minimum relative change between a value and its successors, to consider the successors an anomalous" help="offset group. See condition (2). If ``None``, condition (2) is not tested." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagRaise">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="thresh" type="float" value="" optional="false" label="The threshold, for the total rise (:py:attr:`thresh` ``&gt; 0``)," help="or total drop (:py:attr:`thresh` ``&lt; 0``), value courses must&#10;    not exceed within a timespan of length :py:attr:`raise_window`." space_between_arg="="/>
              <param argument="raise_window" type="text" value="" optional="false" label="An offset string, determining the timespan, the rise/drop" help="thresholding refers to. Window is inclusively defined." space_between_arg="="/>
              <param argument="freq" type="text" value="" optional="false" label="An offset string, determining the frequency, the timeseries" help="to flag is supposed to be sampled at. The window is inclusively&#10;    defined." space_between_arg="="/>
              <param argument="average_window" type="text" optional="true" label="See condition (2) of the description given in the Notes" help="is inclusively defined, defaults to 1.5 times the size of&#10;    :py:attr:`raise_window`." space_between_arg="="/>
              <param argument="raise_factor" type="float" value="2.0" optional="false" label="See condition (2)" help="" space_between_arg="="/>
              <param argument="slope" type="float" optional="true" label="See condition (3)" help="" space_between_arg="="/>
              <param argument="weight" type="float" value="0.8" optional="false" label="See condition (3)" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagRange">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="min" type="float" value="-inf" optional="false" label="Lower bound for valid data" help="" space_between_arg="="/>
              <param argument="max" type="float" value="inf" optional="false" label="Upper bound for valid data" help="" space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagUniLOF">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="n" type="integer" value="20" optional="false" label="Number of periods to be included into the LOF calculation" help="Defaults to `20`, which is a value found to be suitable in&#10;    the literature.&#10;    &#10;    * :py:attr:`n` determines the &quot;locality&quot; of an observation&#10;      (its :py:attr:`n` nearest neighbors) and sets the upper&#10;      limit to the number of values in an outlier clusters (i.e.&#10;      consecutive outliers). Outlier clusters of size greater&#10;      than :py:attr:`n`/2 may not be detected reliably.&#10;    * The larger :py:attr:`n`, the lesser the algorithm's sensitivity&#10;      to local outliers and small or singleton outlier points.&#10;      Higher values greatly increase numerical costs." space_between_arg="="/>
              <conditional name="thresh_cond">
                <param name="thresh_select" type="select" label="thresh mode">
                  <option value="auto">automatic</option>
                  <option value="linear">linear</option>
                </param>
                <when value="auto">
                  <param name="thresh" type="hidden" value="auto" label=""/>
                </when>
                <when value="linear">
                  <param argument="thresh" type="float" value="1.5" optional="false" label="The threshold for flagging the calculated LOF" help="``1`` is considered normal and most likely corresponds to&#10;    inlier points. This parameter is considered the main calibration&#10;    parameter of the algorithm.&#10;    &#10;    * The threshing defaults to ``1.5``, wich is the default value&#10;      found to be suitable in the literature.&#10;    * ``'auto'`` enables flagging the scores with a modified 3-sigma&#10;      rule, resulting in a thresh around ``4``, which usually&#10;      greatly mitigates overflagging compared to the literature&#10;      recommendation, but often is too high.&#10;    * sensitive range for the parameter may be ``[1,15]``, assuming&#10;      default settings for the other parameters." space_between_arg="="/>
                </when>
              </conditional>
              <param argument="algorithm" type="select" value="ball_tree" optional="false" label="Algorithm used for calculating the :py:attr:`n`-nearest neighbors" help="needed for LOF calculation." space_between_arg="=">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="1" optional="false" label="Degree of the metric (&quot;Minkowski&quot;), according to which distance" help="to neighbors is determined. Most important values are:&#10;    &#10;    * ``1`` - Manhatten Metric&#10;    * ``2`` - Euclidian Metric" space_between_arg="="/>
              <conditional name="density_cond">
                <param name="density_select" type="select" label="density mode">
                  <option value="auto">automatic</option>
                  <option value="linear">linear</option>
                </param>
                <when value="auto">
                  <param name="density" type="hidden" value="auto" label=""/>
                </when>
                <when value="linear">
                  <param argument="density" type="float" value="" optional="false" label="How to calculate the temporal distance/density for the variable" help="to flag.&#10;    &#10;    * ``'auto'`` - introduces linear density with an increment&#10;      equal to the median of the absolute diff of the variable to flag.&#10;    * ``float`` - introduces linear density with an increment&#10;      equal to :py:attr:`density`" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="fill_na" type="boolean" label="If True, NaNs in the data are filled with a linear interpolation" help="" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="slope_correct" type="boolean" label="if True, a correction is applied, that removes outlier cluster that actually" help="just seem to be steep slopes" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="min_offset" type="float" optional="true" label="If set, only those outlier cluster will be flagged, that are preceeded and succeeeded" help="by sufficiently large value &quot;jumps&quot;. Defaults to estimating the sufficient value jumps from&#10;    the median over the absolute step sizes between data points." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
            <when value="flagZScore">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="List of variables names to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="method" type="select" value="standard" optional="false" label="Which method to use for ZScoring:" help="* `&quot;standard&quot;`: standard Zscoring, using *mean* for the expectation and *standard deviation (std)* as scaling factor&#10;    * `&quot;modified&quot;`: modified Zscoring, using *median* as the expectation and *median absolute deviation (MAD)* as the scaling Factor&#10;    &#10;    See notes section for detailed scoring formula" space_between_arg="=">
                <option value="standard">standard</option>
                <option value="modified">modified</option>
              </param>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="none">None</option>
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" optional="true" label="Size of the window" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" optional="true" label="Size of the window" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
                <when value="none">
                  <param name="window" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="thresh" type="float" value="3" optional="false" label="Cutoff level for the Zscores, above which associated points are marked as outliers" help="" space_between_arg="="/>
              <param argument="min_residuals" type="integer" optional="true" label="Minimum residual value points must have to be considered outliers" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of valid meassurements in a scoring window, to consider the resulting score valid" help="" space_between_arg="="/>
              <param argument="center" type="boolean" label="Weather or not to center the target value in the scoring window" help="target value is the last value in the window." checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="axis" type="integer" value="0" optional="false" label="Along which axis to calculate the scoring statistics:" help="* `0` (default) - calculate statistics along time axis&#10;    * `1` - calculate statistics over multiple variables&#10;    &#10;    See Notes section for a visual clarification of the workings&#10;    of `axis` and `window`." space_between_arg="="/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="pattern">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="flagPatternByDTW">flagPatternByDTW: Pattern Recognition via Dynamic Time Warping</option>
            </param>
            <when value="flagPatternByDTW">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="reference" type="text" value="" optional="false" label="The name in `data` which holds the pattern" help="not have NaNs, have a datetime index and must not be empty." space_between_arg="="/>
              <param argument="max_distance" type="float" value="0.0" optional="false" label="Maximum dtw-distance between chunk and pattern, if the distance" help="is lower than ``max_distance`` the data gets flagged. With&#10;    default, ``0.0``, only exact matches are flagged." space_between_arg="="/>
              <param argument="normalize" type="boolean" label="If `False`, return unmodified distances" help="If `True`, normalize distances by the number of observations&#10;    of the reference. This helps to make it easier to find a&#10;    good cutoff threshold for further processing. The distances&#10;    then refer to the mean distance per datapoint, expressed&#10;    in the datas units." checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="plot" type="boolean" label="Show a calibration plot, which can be quite helpful to find" help="the right threshold for `max_distance`. It works best with&#10;    `normalize=True`. Do not use in automatic setups / pipelines.&#10;    The plot show three lines:&#10;    &#10;    - data: the data the function was called on&#10;    - distances: the calculated distances by the algorithm&#10;    - indicator: have to distinct levels: `0` and the value of&#10;      `max_distance`. If `max_distance` is `0.0` it defaults to&#10;      `1`. Everywhere where the indicator is not `0` the data&#10;      will be flagged." checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="flag" type="float" value="255.0" optional="false" label="The flag value the function uses to mark observations" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="resampling">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="concatFlags">concatFlags: Project flags/history of :py:attr:`field` to :py:attr:`target` and adjust to the frequeny grid</option>
              <option value="reindex">reindex: Change a variables index</option>
              <option value="resample">resample: Resample data points and flags to a regular frequency</option>
            </param>
            <when value="concatFlags">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="target" type="text" optional="true" label="Variable name to which the results are written" help="" space_between_arg="="/>
              <param argument="method" type="select" value="auto" optional="false" label="Method to project the flags of :py:attr:`field` to the flags to :py:attr:`target`:" help="* ``'auto'``: invert the last alignment/resampling operation (that is not already inverted)&#10;    * ``'nagg'``: project a flag of :py:attr:`field` to all timestamps of&#10;      :py:attr:`target` within the range +/- :py:attr:`freq`/2.&#10;    * ``'bagg'``: project a flag of :py:attr:`field` to all preceeding timestamps&#10;      of :py:attr:`target` within the range :py:attr:`freq`&#10;    * ``'fagg'``: project a flag of :py:attr:`field` to all succeeding timestamps&#10;      of :py:attr:`target` within the range :py:attr:`freq`&#10;    * ``'interpolation'`` - project a flag of :py:attr:`field` to all timestamps&#10;      of :py:attr:`target` within the range +/- :py:attr:`freq`&#10;    * ``'sshift'`` - same as interpolation&#10;    * ``'nshift'`` - project a flag of :py:attr:`field` to the neaerest timestamps&#10;      in :py:attr:`target` within the range +/- :py:attr:`freq`/2&#10;    * ``'bshift'`` - project a flag of :py:attr:`field` to nearest preceeding&#10;      timestamps in :py:attr:`target`&#10;    * ``'nshift'`` - project a flag of :py:attr:`field` to nearest succeeding&#10;      timestamps in :py:attr:`target`&#10;    * ``'match'`` - project a flag of :py:attr:`field` to all identical timestamps&#10;      :py:attr:`target`" space_between_arg="=">
                <option value="fagg">fagg</option>
                <option value="bagg">bagg</option>
                <option value="nagg">nagg</option>
                <option value="fshift">fshift</option>
                <option value="bshift">bshift</option>
                <option value="nshift">nshift</option>
                <option value="sshift">sshift</option>
                <option value="match">match</option>
                <option value="auto">auto</option>
              </param>
              <param argument="invert" type="boolean" label="If True, not the actual method is applied, but its inversion-method" help="" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="freq" type="text" optional="true" label="Projection range" help="" space_between_arg="="/>
              <param argument="drop" type="boolean" label="Remove :py:attr:`field` if ``True``" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="squeeze" type="boolean" label="Squeeze the history into a single column if ``True``, function specific flag information is lost" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="override" type="boolean" label="Overwrite existing flags if ``True``" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
            <when value="reindex">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="method" type="select" value="match" optional="false" label="Determines which of the origins indexes periods to comprise into the calculation of a new flag and a new data value at" help="any period of the new index.&#10;    &#10;    * Aggregations Reindexer. Aggregations are data and flags independent, (pure) index selection methods:&#10;    * `'bagg'`/`'fagg'`: &quot;backwards/forwards aggregation&quot;. Any new index period gets assigned an&#10;      aggregation of the values at periods in the original index, that lie between itself and its successor/predecessor.&#10;    * `'nagg'`: &quot;nearest aggregation&quot;: Any new index period gets assigned an aggregation of the values at periods&#10;      in the original index between its direcet predecessor and successor, it is the nearest neighbor to.&#10;    * Rolling reindexer. Rolling reindexers are equal to aggregations, when projecting between&#10;      regular and irregular sampling grids forth and back. But due to there simple rolling window construction, they are&#10;      easier to comprehend, predict and parametrize. On the downside, they are much more expensive computationally and&#10;      Also, periods can get included in the aggregation to multpiple target periods, (when rolling windows overlap).&#10;    * `'broll'`/`'froll'`: Any new index period gets assigned an aggregation of all the values at periods&#10;      of the original index, that fall into a directly preceeding/succeeding window of size `reindex_window`.&#10;    * Shifts. Shifting methods are shortcuts for aggregation reindex methods, combined with selecting&#10;      'last' or 'first' as the `data_aggregation` method. Therefor, both, the `flags_aggregation`&#10;      and the `data_aggregation` are ignored when using a `shift` reindexer. Also, periods&#10;      where the data evaluates to `NaN` are dropped before shift index selection.&#10;    * `'bshift'`/`fshift`: &quot;backwards/forwards shift&quot;. Any new index period gets assigned the&#10;      first/last valid (not a data NaN) value it succeeds/preceeds&#10;    * `'nshift'`: &quot;nearest shift&quot;: Any new index period gets assigned the value of its closest neighbor in the&#10;      original index.&#10;    * Pillar point Mappings. Index selection method designed to select indices suitable for&#10;      linearly interpolating index values from surrounding pillar points in the original index, or inverting such&#10;      a selection. Periods where the data evaluates to `NaN`, are dropped from consideration.&#10;    * `'mshift'`: &quot;Merge&quot; predecessors and successors. Any new index period gets assigned an aggregation/interpolation comprising&#10;      the last and the next valid period in the original index.&#10;    * `'sshift'`: &quot;Split&quot;-map values onto predecessors and successors. Same as `mshift`, but with a correction that prevents missing value&#10;      flags from being mapped to continuous data chunk bounds.&#10;    * Inversion of last method: try to select the method, that&#10;    * `'invert``" space_between_arg="=">
                <option value="fagg">fagg</option>
                <option value="bagg">bagg</option>
                <option value="nagg">nagg</option>
                <option value="froll">froll</option>
                <option value="broll">broll</option>
                <option value="nroll">nroll</option>
                <option value="fshift">fshift</option>
                <option value="bshift">bshift</option>
                <option value="nshift">nshift</option>
                <option value="match">match</option>
                <option value="sshift">sshift</option>
                <option value="mshift">mshift</option>
                <option value="invert">invert</option>
              </param>
              <param argument="tolerance" type="text" optional="true" label="Limiting the distance, values can be shifted or comprised into aggregation" help="" space_between_arg="="/>
              <param argument="broadcast" type="boolean" label="Weather to propagate aggregation result to full reindex window when using aggregation reindexer" help="(as opposed to only assign to next/previous/closest)" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="squeeze" type="boolean" label="squeeze" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="override" type="boolean" label="override" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
            <when value="resample">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="freq" type="text" value="" optional="false" label="Offset string" help="" space_between_arg="="/>
              <param argument="method" type="select" value="bagg" optional="false" label="Specifies which intervals to be aggregated for a certain timestamp" help="succeeding or &quot;surrounding&quot; interval). See description above for more details." space_between_arg="=">
                <option value="fagg">fagg</option>
                <option value="bagg">bagg</option>
                <option value="nagg">nagg</option>
              </param>
              <param argument="maxna" type="integer" optional="true" label="Maximum number of allowed ``NaN``s in a resampling interval" help="aggregation of the interval evaluates to ``NaN``." space_between_arg="="/>
              <param argument="maxna_group" type="integer" optional="true" label="Same as `maxna` but for consecutive NaNs" help="" space_between_arg="="/>
              <param argument="squeeze" type="boolean" label="squeeze" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="residuals">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="calculatePolynomialResiduals">calculatePolynomialResiduals: Fits a polynomial model to the data and calculate the residuals</option>
              <option value="calculateRollingResiduals">calculateRollingResiduals: Calculate the diff of a rolling-window function and the data</option>
            </param>
            <when value="calculatePolynomialResiduals">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="The size of the window you want to use for fitting" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="The size of the window you want to use for fitting" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="order" type="integer" value="" optional="false" label="The degree of the polynomial used for fitting" help="" space_between_arg="="/>
              <param argument="min_periods" type="integer" value="0" optional="false" label="The minimum number of periods, that has to be available in every values" help="fitting surrounding for the polynomial fit to be performed. If there are not&#10;    enough values, np.nan gets assigned. Default (0) results in fitting&#10;    regardless of the number of values present (results in overfitting for too&#10;    sparse intervals). To automatically set the minimum number of periods to the&#10;    number of values in an offset defined window size, pass np.nan." space_between_arg="="/>
            </when>
            <when value="calculateRollingResiduals">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="The size of the window you want to roll with" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="The size of the window you want to roll with" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="0" optional="false" label="The minimum number of periods to get a valid value" help="" space_between_arg="="/>
              <param argument="center" type="boolean" label="If True, center the rolling window" help="" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="rolling">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="rolling">rolling: Calculate a rolling-window function on the data</option>
            </param>
            <when value="rolling">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="window_cond">
                <param argument="window_select" type="select" label="window input mode">
                  <option value="number">number</option>
                  <option value="timedelta">timedelta</option>
                </param>
                <when value="number">
                  <param argument="window" type="integer" value="" optional="false" label="The size of the window you want to roll with" help="Number of values" space_between_arg="="/>
                </when>
                <when value="timedelta">
                  <param argument="window" type="text" value="" optional="false" label="The size of the window you want to roll with" help="Temporal extensions (offset string)" space_between_arg="="/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="0" optional="false" label="The minimum number of periods to get a valid value" help="" space_between_arg="="/>
              <param argument="center" type="boolean" label="If True, center the rolling window" help="" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="scores">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="assignKNNScore">assignKNNScore: Score datapoints by an aggregation of the distances to their `k` nearest neighbors</option>
              <option value="assignLOF">assignLOF: Assign Local Outlier Factor (LOF)</option>
              <option value="assignUniLOF">assignUniLOF: Assign "univariate" Local Outlier Factor (LOF)</option>
              <option value="assignZScore">assignZScore: Calculate (rolling) Zscores</option>
            </param>
            <when value="assignKNNScore">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="List of variables names to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="target" type="text" value="" optional="false" label="Variable name to which the results are written" help="" space_between_arg="="/>
              <param argument="n" type="integer" value="10" optional="false" label="The number of nearest neighbors to which the distance is comprised in every datapoints scoring calculation" help="" space_between_arg="="/>
              <conditional name="freq_cond">
                <param name="freq_select" type="select" label="freq input mode">
                  <option value="none">None</option>
                  <option value="number">Give as period length</option>
                  <option value="offset">specify as offset</option>
                </param>
                <when value="none"/>
                <when value="number">
                  <param argument="freq" type="float" value="inf" optional="true" label="Determines the segmentation of the data into partitions, the kNN algorithm is" help="Multiple of sampling rate" space_between_arg="="/>
                </when>
                <when value="offset">
                  <param argument="freq" type="text" value="inf" optional="true" label="Determines the segmentation of the data into partitions, the kNN algorithm is" help="offset frequency string" space_between_arg="="/>
                </when>
                <when value="none">
                  <param name="freq" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="2" optional="false" label="The minimum number of periods that have to be present in a window for the kNN scoring" help="to be applied. If the number of periods present is below `min_periods`, the score for the&#10;    datapoints in that window will be np.nan." space_between_arg="="/>
              <param argument="algorithm" type="select" value="ball_tree" optional="false" label="The search algorithm to find each datapoints k nearest neighbors" help="The keyword just gets passed on to the underlying sklearn method.&#10;    See reference [1] for more information on the algorithm." space_between_arg="=">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="metric" type="text" value="minkowski" optional="false" label="The metric the distances to any datapoints neighbors is computed with" help="together with the default of `p` result in the euclidian to be applied.&#10;    The keyword just gets passed on to the underlying sklearn method.&#10;    See reference [1] for more information on the algorithm." space_between_arg="="/>
              <param argument="p" type="integer" value="2" optional="false" label="The grade of the metrice specified by parameter `metric`" help="The keyword just gets passed on to the underlying sklearn method.&#10;    See reference [1] for more information on the algorithm." space_between_arg="="/>
            </when>
            <when value="assignLOF">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="List of variables names to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="target" type="text" value="" optional="false" label="Variable name to which the results are written" help="" space_between_arg="="/>
              <param argument="n" type="integer" value="20" optional="false" label="Number of periods to be included into the LOF calculation" help="suitable in the literature." space_between_arg="="/>
              <conditional name="freq_cond">
                <param name="freq_select" type="select" label="freq input mode">
                  <option value="none">None</option>
                  <option value="number">Give as period length</option>
                  <option value="offset">specify as offset</option>
                </param>
                <when value="none"/>
                <when value="number">
                  <param argument="freq" type="float" value="inf" optional="true" label="Determines the segmentation of the data into partitions, the kNN algorithm is" help="Multiple of sampling rate" space_between_arg="="/>
                </when>
                <when value="offset">
                  <param argument="freq" type="text" value="inf" optional="true" label="Determines the segmentation of the data into partitions, the kNN algorithm is" help="offset frequency string" space_between_arg="="/>
                </when>
                <when value="none">
                  <param name="freq" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="min_periods" type="integer" value="2" optional="false" label="min_periods" help="" space_between_arg="="/>
              <param argument="algorithm" type="select" value="ball_tree" optional="false" label="Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation" help="" space_between_arg="=">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="2" optional="false" label="Degree of the metric (&quot;Minkowski&quot;), according to wich distance to neighbors is determined" help="Most important values are:&#10;    &#10;    * `1` - Manhatten Metric&#10;    * `2` - Euclidian Metric" space_between_arg="="/>
            </when>
            <when value="assignUniLOF">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="n" type="integer" value="20" optional="false" label="Number of periods to be included into the LOF calculation" help="suitable in the literature.&#10;    &#10;    * `n` determines the &quot;locality&quot; of an observation (its `n` nearest neighbors) and sets the upper limit of&#10;      values of an outlier clusters (i.e. consecutive outliers). Outlier clusters of size greater than `n/2`&#10;      may not be detected reliably.&#10;    * The larger `n`, the lesser the algorithm's sensitivity to local outliers and small or singleton outliers&#10;      points. Higher values greatly increase numerical costs." space_between_arg="="/>
              <param argument="algorithm" type="select" value="ball_tree" optional="false" label="Algorithm used for calculating the `n`-nearest neighbors needed for LOF calculation" help="" space_between_arg="=">
                <option value="ball_tree">ball_tree</option>
                <option value="kd_tree">kd_tree</option>
                <option value="brute">brute</option>
                <option value="auto">auto</option>
              </param>
              <param argument="p" type="integer" value="1" optional="false" label="Degree of the metric (&quot;Minkowski&quot;), according to wich distance to neighbors is determined" help="Most important values are:&#10;    &#10;    * `1` - Manhatten Metric&#10;    * `2` - Euclidian Metric" space_between_arg="="/>
              <conditional name="density_cond">
                <param name="density_select" type="select" label="density mode">
                  <option value="auto">automatic</option>
                  <option value="linear">linear</option>
                </param>
                <when value="auto">
                  <param name="density" type="hidden" value="auto" label=""/>
                </when>
                <when value="linear">
                  <param argument="density" type="float" value="" optional="false" label="How to calculate the temporal distance/density for the variable-to-be-flagged" help="* float - introduces linear density with an increment equal to `density`&#10;    * Callable - calculates the density by applying the function passed onto the variable to be flagged&#10;      (passed as Series)." space_between_arg="="/>
                </when>
              </conditional>
              <param argument="fill_na" type="boolean" label="If True, NaNs in the data are filled with a linear interpolation" help="" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
            <when value="assignZScore">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="window" type="text" optional="true" label="Size of the window" help="* Offset String, denoting the windows temporal extension&#10;    * Integer, denoting the windows number of periods.&#10;    * `None` (default), All data points share the same scoring window, which than equals the whole&#10;    data." space_between_arg="="/>
              <param argument="center" type="boolean" label="Weather or not to center the target value in the scoring window" help="target value is the last value in the window." checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
              <param argument="min_periods" type="integer" optional="true" label="Minimum number of valid meassurements in a scoring window, to consider the resulting score valid" help="" space_between_arg="="/>
            </when>
          </conditional>
        </when>
        <when value="tools">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="copyField">copyField: Make a copy of the data and flags of `field`</option>
              <option value="dropField">dropField: Drops field from the data and flags</option>
              <option value="flagByClick">flagByClick: Pop up GUI for adding or removing flags by selection of points in the data plot</option>
              <option value="plot">plot: Plot data and flags or store plot to file</option>
              <option value="renameField">renameField: Rename field in data and flags</option>
              <option value="selectTime">selectTime: Realizes masking within saqc</option>
            </param>
            <when value="copyField">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="target" type="text" value="" optional="false" label="Variable name to which the results are written" help="" space_between_arg="="/>
              <param argument="overwrite" type="boolean" label="overwrite target, if already existant" help="" checked="false" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
            <when value="dropField">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
            </when>
            <when value="flagByClick">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="max_gap" type="text" optional="true" label="If ``None``, all data points will be connected, resulting in long linear" help="lines, in case of large data gaps. ``NaN`` values will be removed before&#10;    plotting. If an offset string is passed, only points that have a distance&#10;    below ``max_gap`` are connected via the plotting line." space_between_arg="="/>
              <param argument="gui_mode" type="select" value="GUI" optional="false" label="* ``&quot;GUI&quot;`` (default), spawns TK based pop-up GUI, enabling scrolling and binding for subplots" help="* ``&quot;overlay&quot;``, spawns matplotlib based pop-up GUI. May be less conflicting, but does not support&#10;      scrolling or binding." space_between_arg="=">
                <option value="GUI">GUI</option>
                <option value="overlay">overlay</option>
              </param>
              <param argument="dfilter" type="float" value="255.0" optional="false" label="Defines which observations will be masked based on the already existing flags" help="" space_between_arg="="/>
            </when>
            <when value="plot">
              <repeat name="field_repeat" title="field(s)" min="1">
                <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              </repeat>
              <param argument="path" type="text" optional="true" label="If ``None`` is passed, interactive mode is entered; plots are shown immediatly" help="and a user need to close them manually before execution continues.&#10;    If a filepath is passed instead, store-mode is entered and&#10;    the plot is stored unter the passed location." space_between_arg="="/>
              <param argument="max_gap" type="text" optional="true" label="If ``None``, all data points will be connected, resulting in long linear" help="lines, in case of large data gaps. ``NaN`` values will be removed before&#10;    plotting. If an offset string is passed, only points that have a distance&#10;    below ``max_gap`` are connected via the plotting line." space_between_arg="="/>
              <conditional name="history_cond">
                <param name="history_select" type="select" label="history mode">
                  <option selected="true" value="valid">valid</option>
                  <option value="complete">complete</option>
                  <option value="list">list</option>
                  <option value="none">None</option>
                </param>
                <when value="valid">
                  <param name="history" type="hidden" value="valid" label=""/>
                </when>
                <when value="complete">
                  <param name="history" type="hidden" value="complete" label=""/>
                </when>
                <when value="list"/>
                <when value="none">
                  <param name="history" type="hidden" value="none" label=""/>
                </when>
                <when value="none">
                  <param name="history" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
              <param argument="dfilter" type="float" value="inf" optional="false" label="Defines which observations will be masked based on the already existing flags" help="" space_between_arg="="/>
            </when>
            <when value="renameField">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="new_name" type="text" value="" optional="false" label="String, field is to be replaced with" help="" space_between_arg="="/>
            </when>
            <when value="selectTime">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <param argument="mode" type="select" value="" optional="false" label="The masking mode" help="- &quot;periodic&quot;: parameters &quot;period_start&quot;, &quot;end&quot; are evaluated to generate a periodical mask&#10;    - &quot;mask_var&quot;: data[mask_var] is expected to be a boolean valued timeseries and is used as mask." space_between_arg="=">
                <option value="periodic">periodic</option>
                <option value="selection_field">selection_field</option>
              </param>
              <param argument="selection_field" type="text" optional="true" label="Only effective if mode == &quot;mask_var&quot;" help="Fieldname of the column, holding the data that is to be used as mask. (must be boolean series)&#10;    Neither the series` length nor its labels have to match data[field]`s index and length. An inner join of the&#10;    indices will be calculated and values get masked where the values of the inner join are ``True``." space_between_arg="="/>
              <param argument="start" type="text" optional="true" label="Only effective if mode == &quot;seasonal&quot;" help="String denoting starting point of every period. Formally, it has to be a truncated instance of &quot;mm-ddTHH:MM:SS&quot;.&#10;    Has to be of same length as `end` parameter.&#10;    See examples section below for some examples." space_between_arg="="/>
              <param argument="end" type="text" optional="true" label="Only effective if mode == &quot;periodic&quot;" help="String denoting starting point of every period. Formally, it has to be a truncated instance of &quot;mm-ddTHH:MM:SS&quot;.&#10;    Has to be of same length as `end` parameter.&#10;    See examples section below for some examples." space_between_arg="="/>
              <param argument="closed" type="boolean" label="Wheather or not to include the mask defining bounds to the mask" help="" checked="true" truevalue="" space_between_arg="=" falsevalue=""/>
            </when>
          </conditional>
        </when>
        <when value="transformation">
          <conditional name="method_cond" label="Method">
            <param name="method_select" type="select" label="Method">
              <option value="transform">transform: Transform data by applying a custom function on data chunks of variable size. Existing flags are preserved</option>
            </param>
            <when value="transform">
              <param argument="field" type="text" value="" optional="false" label="Variable to process" help="" space_between_arg="="/>
              <conditional name="freq_cond">
                <param name="freq_select" type="select" label="freq input mode">
                  <option value="none">None</option>
                  <option value="number">Give as period length</option>
                  <option value="offset">specify as offset</option>
                </param>
                <when value="none"/>
                <when value="number">
                  <param argument="freq" type="float" optional="true" label="Size of the data window" help="Multiple of sampling rate" space_between_arg="="/>
                </when>
                <when value="offset">
                  <param argument="freq" type="text" optional="true" label="Size of the data window" help="offset frequency string" space_between_arg="="/>
                </when>
                <when value="none">
                  <param name="freq" type="hidden" value="__none__" label=""/>
                </when>
              </conditional>
            </when>
          </conditional>
        </when>
      </conditional>
    </repeat>
  </inputs>
  <outputs>
    <data name="output" format="csv" from_work_dir="output.csv" hidden="false"/>
    <data name="config" format="txt" from_work_dir="config.csv" hidden="false"/>
    <collection name="plots" type="list" label="${tool.name} on ${on_string}: Plots">
      <discover_datasets pattern="(?P&lt;name&gt;.*)\.png" ext="png"/>
    </collection>
  </outputs>
  <expand macro="saqc_tests"/>
  <help><![CDATA[TODO]]></help>
  <expand macro="citations"/>
</tool>

